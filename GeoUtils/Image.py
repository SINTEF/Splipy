__doc__ = 'Implementation of image based mesh generation.'

from GoTools import *
from GoTools.SurfaceFactory import *
from GeoUtils.Interpolate import *
from math import *
import cv2
import numpy as np

def getCorners(X, L=50, R=30, D=15):
    """CornerDet detects corners of traced outlines using the SAM04 algorithm.
    The outline is assumed to constitute a discrete closed curve where each
    point is included just once. Increasing D and R will give the same number
    of corners or fewer corners.
    @param X : A traced outline forming a discrete closed curve
    @type  X : numpy array of size nx2
    @param L : Controls the scale at which corners are measured.
    @type  L : Float
    @param R : Controls how close corners can appear.
    @type  R : Float
    @param D : The lower bound for the corner metric. Corner candidates with
               lower metric than this are rejected.
    @type  D : Float
    @return  : The indices of X that consitute corner points
    @rtype   : Numpy array
    """
    n = len(X)

    # Finds corner candidates
    d = np.zeros(n)
    for i in range(1,n+1):
        if i+L <= n:
            k = i+L
            index = np.array(range(i+1,k))
        else:
            k = i+L-n
            index = np.array(range(i+1,n+1)+range(1,k))

        M = X[k-1,:]-X[i-1,:]

        if M[0] == 0:
            dCand = abs(X[index-1,0]-X[i-1,0])
        else:
            m = float(M[1])/M[0]
            dCand = abs(X[index-1,1]-m*X[index-1,0]+m*X[i-1,0]-X[i-1,1])/sqrt(m**2+1)

        Y = max(dCand)
        I = np.argmax(dCand)
        if Y > d[index[I]-1]:
            d[index[I]-1] = Y

    I = np.where(d > 0)[0]
    # Rejects candidates which do not meet the lower metric bound D.
    index  = d <  D
    index2 = d >= D
    d[index] = 0
    C = np.array(range(n))
    C = C[index2]


    # Rejects corners that are too close to a corner with larger metric.
    l = len(C)
    j = 0
    while j+1 < l:
        if abs(C[j]-C[j+1]) <= R:
            if d[C[j]] > d[C[j+1]]:
                C = np.delete(C, j+1)
            else:
                C = np.delete(C, j)
            l = l-1
        else:
            j = j+1

    if l > 0 and abs(C[0]+n-C[-1]) <=R:
        if d[C[-1]] > d[C[0]]:
            C = C[1:-1]
        else:
            C = C[0:-2]

    # always include end-points in corner list, and never closer than 4 indices
    if 0 not in C:
        C = np.insert(C,0,0)
    if (n-1) not in C:
        C = np.append(C,n-1)
    remove = []
    for i in range(1,len(C)-1):
        if C[i]-C[i-1] < 5:
            remove.append(i)
    if C[-1]-C[-2] < 5 and len(C)-2 not in remove:
        remove.append(len(C)-2)

    remove.reverse()
    for j in remove:
        C = np.delete(C,j)

    return C


def ImageCurves(filename):
    """Generate B-spline curves corresponding to the edges in a black/white mask image
    @param filename: Name of image file to read
    @type  filename: String
    @return: All curves generated by tracing the black/white edges
    @rtype:  Curve or list of Curves
    """
    im = cv2.imread(filename)

    # initialize image holders
    imGrey   = np.zeros((len(im),   len(im[0])),   np.uint8)
    imBlack  = np.zeros((len(im),   len(im[0])),   np.uint8)

    # convert to greyscale image
    cv2.cvtColor(im, cv2.cv.CV_RGB2GRAY, imGrey)
    # convert to binary black/white
    cv2.threshold(imGrey, 128, 255, cv2.THRESH_BINARY, imBlack)

    # find contour curves in image
    [contours, hierarchy] = cv2.findContours(imBlack, cv2.RETR_LIST, cv2.CHAIN_APPROX_NONE)

    result = []
    for i in range(len(contours)-1):   # for all contours (except the last one which is the edge)
        pts = contours[i][:,0,:]       # I have no idea why there needs to be a 0 here
        for j in range(len(pts)):      # invert y-axis since images are stored the other way around
            pts[j][1] = len(im[0])-pts[j][1]

        corners = getCorners(pts)
        if len(corners)>2:                        # start/stop tagged as corners. If any inner corners, then
            pts     = np.roll(pts, -corners[1],0) # rearrange points so start/stop falls at a natural corner.
            corners = getCorners(pts)             # recompute corners, since previous sem might be smooth

        SetTolerance(approx=2300)

        n = len(pts)
        parpt = range(n)
        for i in range(n):
            parpt[i] = float(parpt[i]) / (n-1)

        # the choice of knot vector is a tricky one. We'll go with the following strategy:
        # - cubic, p=3 curve
        # - C^0 at corner points (computed above)
        # - at least one C^2 knot between corner knots
        # - otherwise as uniform as possible
        # - starts at 0, ends at 1
        # - around 1/10 the number of control points wrt points
        # - up to a max of 100(ish) control points for large models

        # start off with a uniform(ish) knot vector
        knot = []
        nStart = min(n/10, 90)
        for i in range(nStart+1):
            knot.append(int(1.0*i*(n-1)/nStart))
        c = corners.tolist()
        knot = sorted(list(set(knot+c))) # unique sorted list

        # make sure there is at least one knot between corners
        newKnot = []
        for i in range(len(c)-1):
            if knot.index(c[i+1])-knot.index(c[i]) == 1:
                newKnot.append((c[i+1]+c[i])/2)
        knot = sorted(knot + newKnot)

        # make sure no two knots are too close (typical corners which do this)
        for i in range(1,len(knot)-1):
            if knot[i] not in c:
                knot[i] = (knot[i-1]+knot[i+1])/2.0

        # make C^0 at corners and C^-1 at endpoints by duplicating knots
        knot = sorted(knot + c + c + [0,n-1]) # both c and knot contains a copy of the endpoints

        # make it span [0,1] instead of [0,n-1]
        for i in range(len(knot)):
            knot[i] /= float(n-1)

        c = ApproximateCurve(pts, parpt, knot)

        if len(contours) == 2:
            return c
        else:
            result.append(c)

    return result

def ImageHeight(filename, N=[30,30], p=[4,4]):
    """Generate B-spline surface approximation given by the heightmap in a grayscale image
    @param filename: Name of image file to read
    @type  filename: String
    @param N:        Number of controlpoints in u-direction
    @type  N:        Two Integers
    @param p:        Polynomial order (degree+1)
    @type  p:        Two Integers
    @return:         Normalized (all values between 0 and 1) heightmap approximation
    @rtype:          Surface
    """
    im = cv2.imread(filename)

    width  = len(im)
    height = len(im[0])
    print height,'x',width

    # initialize image holder
    imGrey = np.zeros((len(im),   len(im[0])),   np.uint8)

    # convert to greyscale image
    cv2.cvtColor(im, cv2.cv.CV_RGB2GRAY, imGrey)

    pts = []
    # guess uniform evaluation points and knot vectors
    u = range(width)
    v = range(height)
    knot1 = [0]*3 + range(N[0]-p[0]+2) + [N[0]-p[0]+1]*3
    knot2 = [0]*3 + range(N[0]-p[0]+2) + [N[0]-p[0]+1]*3

    # normalize all values to be in range [0, 1]
    u     = [float(i)/u[-1]     for i in u]
    v     = [float(i)/v[-1]     for i in v]
    knot1 = [float(i)/knot1[-1] for i in knot1]
    knot2 = [float(i)/knot2[-1] for i in knot2]

    for j in range(height):
        for i in range(width):
            pts.append([v[j], u[i], float(imGrey[width-i-1][j])/255.0*1.0])

    return ApproximateSurface(pts,u,v,knot1,knot2)

def ImageConvexSurface(filename):
    """Generate a single B-spline surface corresponding to convex black domain of a black/white mask image. The algorithm
       traces the boundary and searches for 4 natural corner points. It will then generate 4 boundary curves which will be
       used to create the surface by Coons Patch. If less than 4 corners are found, the rest is generated at the center of
       the largest span (possibly creating a 180 degree corner), and if more than 4 corners are found, then the excess corners
       are placed on curve interiors, thus contributing to internal C0 parametrization. Many non-convex domains will produce
       good surfaces, but for these domains there is no guarantee against self-intersection. All convex domains will work. 
    @param filename: Name of image file to read
    @type  filename: String
    @return        : B-spline surface
    @rtype         : Surface
    """
    # generate boundary curve
    crv = ImageCurves(filename);

    # error test input
    if type(crv) is list:
        print 'Error: ImageConvexSurface expects a single closed curve. Multiple curves detected'
        return None

    # parametric value of corner candidates. These are all in the range [0,1] and both 0 and 1 is present
    kinks = crv.GetKinks()

    # generate 4 corners
    if len(kinks) == 2:
        corners = [.25, .5, .75]

    elif len(kinks) == 3:
        corners = [(0+kinks[1])/2, kinks[1], (1+kinks[1])/2]

    elif len(kinks) == 4:
        if kinks[1]-kinks[0] > kinks[2]-kinks[1] and kinks[1]-kinks[0] > kinks[3]-kinks[2]:
            corners = [(kinks[0]+kinks[1])/2] + kinks[1:3]
        elif kinks[2]-kinks[1] > kinks[3]-kinks[2]:
            corners = [kinks[1], (kinks[1]+kinks[2])/2], kinks[2]
        else:
            corners = kinks[1:3] + [(kinks[2]+kinks[3])/2]
    
    else:
        while len(kinks) > 5:
            max_span   = 0
            max_span_i = 0
            for i in range(1,len(kinks)-1):
                max_span   = max(max_span, kinks[i+1]-kinks[i-1])
                max_span_i = i
            del kinks[max_span_i]
        corners = kinks[1:4]

    return CoonsSurfacePatch(crv.Split(corners));

