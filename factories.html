
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Factories &#8212; Splipy 1.2.0 documentation</title>
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Splipy 1.2.0 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="factories">
<h1>Factories<a class="headerlink" href="#factories" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-splipy.curve_factory">
<span id="curves"></span><h2>Curves<a class="headerlink" href="#module-splipy.curve_factory" title="Permalink to this headline">¶</a></h2>
<p>Handy utilities for creating curves.</p>
<dl class="class">
<dt id="splipy.curve_factory.Boundary">
<em class="property">class </em><code class="descclassname">splipy.curve_factory.</code><code class="descname">Boundary</code><a class="reference internal" href="_modules/splipy/curve_factory.html#Boundary"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.curve_factory.Boundary" title="Permalink to this definition">¶</a></dt>
<dd><p>Enumeration representing different boundary conditions used in
<a class="reference internal" href="#splipy.curve_factory.interpolate" title="splipy.curve_factory.interpolate"><code class="xref py py-func docutils literal notranslate"><span class="pre">interpolate()</span></code></a>.</p>
<dl class="attribute">
<dt id="splipy.curve_factory.Boundary.FREE">
<code class="descname">FREE</code><em class="property"> = 1</em><a class="headerlink" href="#splipy.curve_factory.Boundary.FREE" title="Permalink to this definition">¶</a></dt>
<dd><p>The curve will be smooth at the second and second-to-last unique knot.</p>
</dd></dl>

<dl class="attribute">
<dt id="splipy.curve_factory.Boundary.HERMITE">
<code class="descname">HERMITE</code><em class="property"> = 3</em><a class="headerlink" href="#splipy.curve_factory.Boundary.HERMITE" title="Permalink to this definition">¶</a></dt>
<dd><p>Specify the derivatives at the knots.</p>
</dd></dl>

<dl class="attribute">
<dt id="splipy.curve_factory.Boundary.NATURAL">
<code class="descname">NATURAL</code><em class="property"> = 2</em><a class="headerlink" href="#splipy.curve_factory.Boundary.NATURAL" title="Permalink to this definition">¶</a></dt>
<dd><p>The curve will have zero second derivatives at the endpoints.</p>
</dd></dl>

<dl class="attribute">
<dt id="splipy.curve_factory.Boundary.PERIODIC">
<code class="descname">PERIODIC</code><em class="property"> = 4</em><a class="headerlink" href="#splipy.curve_factory.Boundary.PERIODIC" title="Permalink to this definition">¶</a></dt>
<dd><p>The curve will be periodic at the endpoints.</p>
</dd></dl>

<dl class="attribute">
<dt id="splipy.curve_factory.Boundary.TANGENT">
<code class="descname">TANGENT</code><em class="property"> = 5</em><a class="headerlink" href="#splipy.curve_factory.Boundary.TANGENT" title="Permalink to this definition">¶</a></dt>
<dd><p>Specify the tangents at the endpoints.</p>
</dd></dl>

<dl class="attribute">
<dt id="splipy.curve_factory.Boundary.TANGENTNATURAL">
<code class="descname">TANGENTNATURAL</code><em class="property"> = 6</em><a class="headerlink" href="#splipy.curve_factory.Boundary.TANGENTNATURAL" title="Permalink to this definition">¶</a></dt>
<dd><p>Use <cite>TANGENT</cite> for the start and <cite>NATURAL</cite> for the end.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="splipy.curve_factory.line">
<code class="descclassname">splipy.curve_factory.</code><code class="descname">line</code><span class="sig-paren">(</span><em>a</em>, <em>b</em>, <em>relative=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/curve_factory.html#line"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.curve_factory.line" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a line between two points.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>a</strong> (<em>array-like</em>) – Start point</li>
<li><strong>b</strong> (<em>array-like</em>) – End point</li>
<li><strong>relative</strong> (<em>bool</em>) – Whether <em>b</em> is relative to <em>a</em></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Linear curve from <em>a</em> to <em>b</em></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="basic_classes.html#splipy.Curve" title="splipy.Curve">Curve</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="splipy.curve_factory.polygon">
<code class="descclassname">splipy.curve_factory.</code><code class="descname">polygon</code><span class="sig-paren">(</span><em>*points</em>, <em>**keywords</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/curve_factory.html#polygon"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.curve_factory.polygon" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a linear interpolation between input points.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>points</strong> (<em>[</em><em>array-like</em><em>]</em>) – The points to interpolate</li>
<li><strong>relative</strong> (<em>bool</em>) – If controlpoints are interpreted as relative to the
previous one</li>
<li><strong>t</strong> (<em>[</em><em>float</em><em>]</em>) – specify parametric interpolation points (the knot vector)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Linear curve through the input points</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="basic_classes.html#splipy.Curve" title="splipy.Curve">Curve</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="splipy.curve_factory.n_gon">
<code class="descclassname">splipy.curve_factory.</code><code class="descname">n_gon</code><span class="sig-paren">(</span><em>n=5</em>, <em>r=1</em>, <em>center=(0</em>, <em>0</em>, <em>0)</em>, <em>normal=(0</em>, <em>0</em>, <em>1)</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/curve_factory.html#n_gon"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.curve_factory.n_gon" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a regular polygon of <em>n</em> equal sides centered at the origin.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>n</strong> (<em>int</em>) – Number of sides and vertices</li>
<li><strong>r</strong> (<em>float</em>) – Radius</li>
<li><strong>center</strong> (<em>array-like</em>) – local origin</li>
<li><strong>normal</strong> (<em>array-like</em>) – local normal</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A linear, periodic, 2D curve</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference internal" href="basic_classes.html#splipy.Curve" title="splipy.Curve">Curve</a></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><strong>ValueError</strong> – If radius is not positive</li>
<li><strong>ValueError</strong> – If <em>n</em> &lt; 3</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="splipy.curve_factory.circle">
<code class="descclassname">splipy.curve_factory.</code><code class="descname">circle</code><span class="sig-paren">(</span><em>r=1</em>, <em>center=(0</em>, <em>0</em>, <em>0)</em>, <em>normal=(0</em>, <em>0</em>, <em>1)</em>, <em>type='p2C0'</em>, <em>xaxis=(1</em>, <em>0</em>, <em>0)</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/curve_factory.html#circle"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.curve_factory.circle" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a circle.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>r</strong> (<em>float</em>) – Radius</li>
<li><strong>center</strong> (<em>array-like</em>) – local origin</li>
<li><strong>normal</strong> (<em>array-like</em>) – local normal</li>
<li><strong>type</strong> (<em>string</em>) – The type of parametrization (‘p2C0’ or ‘p4C1’)</li>
<li><strong>xaxis</strong> (<em>array-like</em>) – direction of sem, i.e. parametric start point t=0</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A periodic, quadratic rational curve</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference internal" href="basic_classes.html#splipy.Curve" title="splipy.Curve">Curve</a></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><strong>ValueError</strong> – If radius is not positive</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="splipy.curve_factory.ellipse">
<code class="descclassname">splipy.curve_factory.</code><code class="descname">ellipse</code><span class="sig-paren">(</span><em>r1=1</em>, <em>r2=1</em>, <em>center=(0</em>, <em>0</em>, <em>0)</em>, <em>normal=(0</em>, <em>0</em>, <em>1)</em>, <em>type='p2C0'</em>, <em>xaxis=(1</em>, <em>0</em>, <em>0)</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/curve_factory.html#ellipse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.curve_factory.ellipse" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an ellipse</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>r1</strong> (<em>float</em>) – Radius along xaxis</li>
<li><strong>r2</strong> (<em>float</em>) – Radius orthogonal to xaxis</li>
<li><strong>center</strong> (<em>array-like</em>) – local origin</li>
<li><strong>normal</strong> (<em>array-like</em>) – local normal</li>
<li><strong>type</strong> (<em>string</em>) – The type of parametrization (‘p2C0’ or ‘p4C1’)</li>
<li><strong>xaxis</strong> (<em>array-like</em>) – direction of sem, i.e. parametric start point t=0</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A periodic, quadratic rational curve</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference internal" href="basic_classes.html#splipy.Curve" title="splipy.Curve">Curve</a></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><strong>ValueError</strong> – If radius is not positive</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="splipy.curve_factory.circle_segment_from_three_points">
<code class="descclassname">splipy.curve_factory.</code><code class="descname">circle_segment_from_three_points</code><span class="sig-paren">(</span><em>x0</em>, <em>x1</em>, <em>x2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/curve_factory.html#circle_segment_from_three_points"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.curve_factory.circle_segment_from_three_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a circle segment going from the point x0 to x2 through x1</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x0</strong> (<em>vector-like</em>) – The start point (2D or 3D point)</li>
<li><strong>x1</strong> (<em>vector-like</em>) – An intermediate point (2D or 3D)</li>
<li><strong>x2</strong> (<em>vector-like</em>) – The end point (2D or 3D)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="basic_classes.html#splipy.Curve" title="splipy.Curve">Curve</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="splipy.curve_factory.circle_segment">
<code class="descclassname">splipy.curve_factory.</code><code class="descname">circle_segment</code><span class="sig-paren">(</span><em>theta</em>, <em>r=1</em>, <em>center=(0</em>, <em>0</em>, <em>0)</em>, <em>normal=(0</em>, <em>0</em>, <em>1)</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/curve_factory.html#circle_segment"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.curve_factory.circle_segment" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a circle segment starting parallel to the rotated x-axis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>theta</strong> (<em>float</em>) – Angle in radians</li>
<li><strong>r</strong> (<em>float</em>) – Radius</li>
<li><strong>center</strong> (<em>array-like</em>) – circle segment center</li>
<li><strong>normal</strong> (<em>array-like</em>) – normal vector to the plane that contains circle</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A quadratic rational curve</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference internal" href="basic_classes.html#splipy.Curve" title="splipy.Curve">Curve</a></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><strong>ValueError</strong> – If radius is not positive</li>
<li><strong>ValueError</strong> – If theta is not in the range <em>[-2pi, 2pi]</em></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="splipy.curve_factory.interpolate">
<code class="descclassname">splipy.curve_factory.</code><code class="descname">interpolate</code><span class="sig-paren">(</span><em>x</em>, <em>basis</em>, <em>t=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/curve_factory.html#interpolate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.curve_factory.interpolate" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform general spline interpolation on a provided basis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>matrix-like</em>) – Matrix <em>X[i,j]</em> of interpolation points <em>xi</em> with
components <em>j</em></li>
<li><strong>basis</strong> (<a class="reference internal" href="basic_classes.html#splipy.BSplineBasis" title="splipy.BSplineBasis"><em>BSplineBasis</em></a>) – Basis on which to interpolate</li>
<li><strong>t</strong> (<em>array-like</em>) – parametric values at interpolation points; defaults to
Greville points if not provided</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Interpolated curve</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="basic_classes.html#splipy.Curve" title="splipy.Curve">Curve</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="splipy.curve_factory.least_square_fit">
<code class="descclassname">splipy.curve_factory.</code><code class="descname">least_square_fit</code><span class="sig-paren">(</span><em>x</em>, <em>basis</em>, <em>t</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/curve_factory.html#least_square_fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.curve_factory.least_square_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a least-square fit of a point cloud onto a spline basis</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>matrix-like</em>) – Matrix <em>X[i,j]</em> of interpolation points <em>xi</em> with
components <em>j</em>. The number of points must be equal to or larger than
the number of basis functions in <em>basis</em></li>
<li><strong>basis</strong> (<a class="reference internal" href="basic_classes.html#splipy.BSplineBasis" title="splipy.BSplineBasis"><em>BSplineBasis</em></a>) – Basis on which to interpolate</li>
<li><strong>t</strong> (<em>array-like</em>) – parametric values at evaluation points</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Approximated curve</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="basic_classes.html#splipy.Curve" title="splipy.Curve">Curve</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="splipy.curve_factory.cubic_curve">
<code class="descclassname">splipy.curve_factory.</code><code class="descname">cubic_curve</code><span class="sig-paren">(</span><em>x</em>, <em>boundary=1</em>, <em>t=None</em>, <em>tangents=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/curve_factory.html#cubic_curve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.curve_factory.cubic_curve" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform cubic spline interpolation on a provided basis.</p>
<p>The valid boundary conditions are enumerated in <a class="reference internal" href="#splipy.curve_factory.Boundary" title="splipy.curve_factory.Boundary"><code class="xref py py-class docutils literal notranslate"><span class="pre">Boundary</span></code></a>. The
meaning of the <cite>tangents</cite> parameter depends on the specified boundary
condition:</p>
<ul class="simple">
<li><cite>TANGENT</cite>: two points,</li>
<li><cite>TANGENTNATURAL</cite>: one point,</li>
<li><cite>HERMITE</cite>: <em>n</em> points</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>matrix-like</em>) – Matrix <em>X[i,j]</em> of interpolation points <em>x_i</em> with
components <em>j</em></li>
<li><strong>boundary</strong> (<em>int</em>) – Any value from <a class="reference internal" href="#splipy.curve_factory.Boundary" title="splipy.curve_factory.Boundary"><code class="xref py py-class docutils literal notranslate"><span class="pre">Boundary</span></code></a>.</li>
<li><strong>t</strong> (<em>array-like</em>) – parametric values at interpolation points, defaults
to Euclidean distance between evaluation points</li>
<li><strong>tangents</strong> (<em>matrix-like</em>) – Tangent information according to the boundary
conditions.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Interpolated curve</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="basic_classes.html#splipy.Curve" title="splipy.Curve">Curve</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="splipy.curve_factory.bezier">
<code class="descclassname">splipy.curve_factory.</code><code class="descname">bezier</code><span class="sig-paren">(</span><em>pts</em>, <em>quadratic=False</em>, <em>relative=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/curve_factory.html#bezier"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.curve_factory.bezier" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a cubic or quadratic bezier curve from a set of control points</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>pts</strong> (<em>[</em><em>array-like</em><em>]</em>) – list of control-points. In addition to a starting
point we need three points per bezier interval for cubic splines and
two points for quadratic splines</li>
<li><strong>quadratic</strong> (<em>bool</em>) – True if a quadratic spline is to be returned, False
if a cubic spline is to be returned</li>
<li><strong>relative</strong> (<em>bool</em>) – If controlpoints are interpreted as relative to the
previous one</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Bezier curve</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="basic_classes.html#splipy.Curve" title="splipy.Curve">Curve</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="splipy.curve_factory.manipulate">
<code class="descclassname">splipy.curve_factory.</code><code class="descname">manipulate</code><span class="sig-paren">(</span><em>crv</em>, <em>f</em>, <em>normalized=False</em>, <em>vectorized=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/curve_factory.html#manipulate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.curve_factory.manipulate" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new curve based on an expression-evaluation of an existing one
:param Curve crv: original curve on which f is to be applied
:param function f: expression of the physical point <em>x</em>, the velocity</p>
<blockquote>
<div>(tangent) <em>v</em>, parametric point <em>t</em> and/or acceleration <em>a</em>.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>normalized</strong> – If velocity and acceleration terms should be normalized
to have length 1</li>
<li><strong>vectorized</strong> – True if <em>f</em> is expressed in terms of vectorized
operations. The method is sped up whenever this is used.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Examples:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">scale_by_two</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span>

<span class="n">new_curve</span> <span class="o">=</span> <span class="n">manipulate</span><span class="p">(</span><span class="n">old_curve</span><span class="p">,</span> <span class="n">scale_by_two</span><span class="p">)</span>
<span class="n">new_curve</span> <span class="o">=</span> <span class="n">old_curve</span> <span class="o">*</span> <span class="mi">2</span> <span class="c1"># will give the same result</span>

<span class="k">def</span> <span class="nf">move_3_to_right</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">x</span>
    <span class="c1"># *v* is velocity. Rotate this 90 to the right and it points (+v[1], -v[0])</span>
    <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">3</span><span class="o">*</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">3</span><span class="o">*</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">result</span>

<span class="c1"># note that the velocity vector will not have length one unless normalized is passed</span>
<span class="n">new_curve</span> <span class="o">=</span> <span class="n">manipulate</span><span class="p">(</span><span class="n">old_curve</span><span class="p">,</span> <span class="n">move_3_to_right</span><span class="p">,</span> <span class="n">normalized</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">move_3_to_right_fast</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">x</span>
    <span class="n">result</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">3</span><span class="o">*</span><span class="n">v</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">result</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">3</span><span class="o">*</span><span class="n">v</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">result</span>

<span class="n">new_curve</span> <span class="o">=</span> <span class="n">manipulate</span><span class="p">(</span><span class="n">old_curve</span><span class="p">,</span> <span class="n">move_3_to_right_fast</span><span class="p">,</span> <span class="n">normalized</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">vectorized</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="splipy.curve_factory.fit">
<code class="descclassname">splipy.curve_factory.</code><code class="descname">fit</code><span class="sig-paren">(</span><em>x</em>, <em>t0</em>, <em>t1</em>, <em>rtol=0.0001</em>, <em>atol=0.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/curve_factory.html#fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.curve_factory.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes an interpolation for a parametric curve up to a specified tolerance.
The method will iteratively refine parts where needed resulting in a non-uniform
knot vector with as optimized knot locations as possible.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>function</em>) – callable function which takes as input a vector of evaluation
points t and gives as output a matrix x where x[i,j] is component j evaluated
at point t[i]</li>
<li><strong>t0</strong> (<em>float</em>) – start of parametric domain</li>
<li><strong>t1</strong> (<em>float</em>) – end of parametric domain</li>
<li><strong>rtol</strong> (<em>float</em>) – relative tolerance for stopping criterium. It is defined
to be ||e||_L2 / D, where D is the length of the curve and ||e||_L2 is the
L2-error (see Curve.error)</li>
<li><strong>atol</strong> (<em>float</em>) – absolute tolerance for stopping criterium. It is defined to
be the maximal distance between the curve approximation and the exact curve</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Curve Non-uniform cubic B-spline curve</p>
</td>
</tr>
</tbody>
</table>
<p>Examples:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">splipy.curve_factory</span> <span class="k">as</span> <span class="nn">curve_factory</span>

<span class="c1"># gives a B-spline approximation to the circle with arclength parametrization</span>
<span class="c1"># unlike curve_factory.circle which is exact, but not arclength</span>
<span class="k">def</span> <span class="nf">arclength_circle</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)]</span> <span class="p">)</span><span class="o">.</span><span class="n">T</span>
<span class="n">crv</span> <span class="o">=</span> <span class="n">curve_factory</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">arclength_circle</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
<span class="nb">print</span> <span class="n">crv</span>

<span class="c1"># approximates a difficult function with wild behaviour around t=0, but</span>
<span class="c1"># this is overcome by a higher knot density around this point</span>
<span class="k">def</span> <span class="nf">one_over_t</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="n">eps</span> <span class="o">=</span> <span class="mf">1e-8</span> <span class="c1"># to avoid 1/0 we add a small epsilon</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="n">eps</span><span class="p">)]</span> <span class="p">)</span><span class="o">.</span><span class="n">T</span>
<span class="n">crv</span> <span class="o">=</span> <span class="n">curve_factory</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">one_over_t</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">)</span>
<span class="nb">print</span> <span class="n">crv</span> <span class="c1"># first knot span is ~1e-9, last knot is ~1e-1</span>

<span class="c1"># one can specify the target curve in terms of existing Curve objects</span>
<span class="n">crv</span> <span class="o">=</span> <span class="n">curve_factory</span><span class="o">.</span><span class="n">circle</span><span class="p">(</span><span class="n">r</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>     <span class="c1"># Curve-object, quadratic NURBS</span>
<span class="k">def</span> <span class="nf">move_along_tangent</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">crv</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">crv</span><span class="o">.</span><span class="n">tangent</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>  <span class="c1"># can evaluate curve or its derivatives</span>
<span class="c1"># fit() will create a B-spline approximation using non-uniform refinement</span>
<span class="n">crv2</span> <span class="o">=</span> <span class="n">curve_factory</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">move_along_tangent</span><span class="p">,</span> <span class="n">crv</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">crv</span><span class="o">.</span><span class="n">end</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-splipy.surface_factory">
<span id="surfaces"></span><h2>Surfaces<a class="headerlink" href="#module-splipy.surface_factory" title="Permalink to this headline">¶</a></h2>
<p>Handy utilities for creating surfaces.</p>
<dl class="function">
<dt id="splipy.surface_factory.square">
<code class="descclassname">splipy.surface_factory.</code><code class="descname">square</code><span class="sig-paren">(</span><em>size=1</em>, <em>lower_left=(0</em>, <em>0)</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/surface_factory.html#square"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.surface_factory.square" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a square with parametric origin at <em>(0,0)</em>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>size</strong> (<em>float</em>) – Size(s), either a single scalar or a tuple of scalars per axis</li>
<li><strong>lower_left</strong> (<em>array-like</em>) – local origin, the lower left corner of the square</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A linear parametrized square</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="basic_classes.html#splipy.Surface" title="splipy.Surface">Surface</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="splipy.surface_factory.disc">
<code class="descclassname">splipy.surface_factory.</code><code class="descname">disc</code><span class="sig-paren">(</span><em>r=1</em>, <em>center=(0</em>, <em>0</em>, <em>0)</em>, <em>normal=(0</em>, <em>0</em>, <em>1)</em>, <em>type='radial'</em>, <em>xaxis=(1</em>, <em>0</em>, <em>0)</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/surface_factory.html#disc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.surface_factory.disc" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a circular disc. The <em>type</em> parameter distinguishes between
different parametrizations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>r</strong> (<em>float</em>) – Radius</li>
<li><strong>center</strong> (<em>array-like</em>) – local origin</li>
<li><strong>normal</strong> (<em>array-like</em>) – local normal</li>
<li><strong>type</strong> (<em>string</em>) – The type of parametrization (‘radial’ or ‘square’)</li>
<li><strong>xaxis</strong> (<em>array-like</em>) – direction of sem, i.e. parametric start point v=0</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The disc</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="basic_classes.html#splipy.Surface" title="splipy.Surface">Surface</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="splipy.surface_factory.sphere">
<code class="descclassname">splipy.surface_factory.</code><code class="descname">sphere</code><span class="sig-paren">(</span><em>r=1</em>, <em>center=(0</em>, <em>0</em>, <em>0)</em>, <em>zaxis=(0</em>, <em>0</em>, <em>1)</em>, <em>xaxis=(1</em>, <em>0</em>, <em>0)</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/surface_factory.html#sphere"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.surface_factory.sphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a spherical shell.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>r</strong> (<em>float</em>) – Radius</li>
<li><strong>center</strong> (<em>array-like</em>) – Local origin of the sphere</li>
<li><strong>zaxis</strong> (<em>array-like</em>) – direction of the north/south pole of the parametrization</li>
<li><strong>xaxis</strong> (<em>array-like</em>) – direction of the longitudal sem</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The spherical shell</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="basic_classes.html#splipy.Surface" title="splipy.Surface">Surface</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="splipy.surface_factory.extrude">
<code class="descclassname">splipy.surface_factory.</code><code class="descname">extrude</code><span class="sig-paren">(</span><em>curve</em>, <em>amount</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/surface_factory.html#extrude"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.surface_factory.extrude" title="Permalink to this definition">¶</a></dt>
<dd><p>Extrude a curve by sweeping it to a given height.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>curve</strong> (<a class="reference internal" href="basic_classes.html#splipy.Curve" title="splipy.Curve"><em>Curve</em></a>) – Curve to extrude</li>
<li><strong>amount</strong> (<em>array-like</em>) – 3-component vector of sweeping amount and
direction</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The extruded curve</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="basic_classes.html#splipy.Surface" title="splipy.Surface">Surface</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="splipy.surface_factory.revolve">
<code class="descclassname">splipy.surface_factory.</code><code class="descname">revolve</code><span class="sig-paren">(</span><em>curve</em>, <em>theta=6.283185307179586</em>, <em>axis=(0</em>, <em>0</em>, <em>1)</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/surface_factory.html#revolve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.surface_factory.revolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Revolve a surface by sweeping a curve in a rotational fashion around
the <em>z</em> axis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>curve</strong> (<a class="reference internal" href="basic_classes.html#splipy.Curve" title="splipy.Curve"><em>Curve</em></a>) – Curve to revolve</li>
<li><strong>theta</strong> (<em>float</em>) – Angle to revolve, in radians</li>
<li><strong>axis</strong> (<em>array-like</em>) – Axis of rotation</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The revolved surface</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="basic_classes.html#splipy.Surface" title="splipy.Surface">Surface</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="splipy.surface_factory.cylinder">
<code class="descclassname">splipy.surface_factory.</code><code class="descname">cylinder</code><span class="sig-paren">(</span><em>r=1</em>, <em>h=1</em>, <em>center=(0</em>, <em>0</em>, <em>0)</em>, <em>axis=(0</em>, <em>0</em>, <em>1)</em>, <em>xaxis=(1</em>, <em>0</em>, <em>0)</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/surface_factory.html#cylinder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.surface_factory.cylinder" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a cylinder shell with no top or bottom</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>r</strong> (<em>float</em>) – Radius</li>
<li><strong>h</strong> (<em>float</em>) – Height</li>
<li><strong>center</strong> (<em>array-like</em>) – The center of the bottom circle</li>
<li><strong>axis</strong> (<em>array-like</em>) – Cylinder axis</li>
<li><strong>xaxis</strong> (<em>array-like</em>) – direction of sem, i.e. parametric start point u=0</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The cylinder shell</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="basic_classes.html#splipy.Surface" title="splipy.Surface">Surface</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="splipy.surface_factory.torus">
<code class="descclassname">splipy.surface_factory.</code><code class="descname">torus</code><span class="sig-paren">(</span><em>minor_r=1</em>, <em>major_r=3</em>, <em>center=(0</em>, <em>0</em>, <em>0)</em>, <em>normal=(0</em>, <em>0</em>, <em>1)</em>, <em>xaxis=(1</em>, <em>0</em>, <em>0)</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/surface_factory.html#torus"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.surface_factory.torus" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a torus (doughnut) by revolving a circle of size <em>minor_r</em>
around the <em>z</em> axis with radius <em>major_r</em>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>minor_r</strong> (<em>float</em>) – The thickness of the torus (radius in the <em>xz</em> plane)</li>
<li><strong>major_r</strong> (<em>float</em>) – The size of the torus (radius in the <em>xy</em> plane)</li>
<li><strong>center</strong> (<em>array-like</em>) – Local origin of the torus</li>
<li><strong>normal</strong> (<em>array-like</em>) – Local origin of the torus</li>
<li><strong>center</strong> – Local origin of the torus</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A periodic torus</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="basic_classes.html#splipy.Surface" title="splipy.Surface">Surface</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="splipy.surface_factory.edge_curves">
<code class="descclassname">splipy.surface_factory.</code><code class="descname">edge_curves</code><span class="sig-paren">(</span><em>*curves</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/surface_factory.html#edge_curves"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.surface_factory.edge_curves" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the surface defined by the region between the input curves.</p>
<p>In case of four input curves, these must be given in an ordered directional
closed loop around the resulting surface.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>curves</strong> (<em>[</em><a class="reference internal" href="basic_classes.html#splipy.Curve" title="splipy.Curve"><em>Curve</em></a><em>]</em>) – Two or four edge curves</li>
<li><strong>type</strong> (<em>string</em>) – The method used for interior computation (‘coons’, ‘poisson’, ‘elasticity’ or ‘finitestrain’)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The enclosed surface</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference internal" href="basic_classes.html#splipy.Surface" title="splipy.Surface">Surface</a></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><strong>ValueError</strong> – If the length of <em>curves</em> is not two or four</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="splipy.surface_factory.thicken">
<code class="descclassname">splipy.surface_factory.</code><code class="descname">thicken</code><span class="sig-paren">(</span><em>curve</em>, <em>amount</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/surface_factory.html#thicken"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.surface_factory.thicken" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a surface by adding thickness to a curve.</p>
<ul class="simple">
<li>For 2D curves this will generate a 2D planar surface with the curve
through the center.</li>
<li>For 3D curves this will generate a surface “tube” which is open at both
ends (that is, for a straight line it will generate a cylinder shell).</li>
</ul>
<p>The resulting surface is an approximation generated by interpolating at the
Greville points. It will use the same discretization as the input curve.
It does not check for self-intersecting geometries.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>curve</strong> (<a class="reference internal" href="basic_classes.html#splipy.Curve" title="splipy.Curve"><em>Curve</em></a>) – The generating curve</li>
<li><strong>amount</strong> – The amount of thickness, either constant or variable (if
variable, the function must accept parameters named <em>x</em>, <em>y</em>, <em>z</em> and/or <em>t</em>)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Surrounding surface</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="basic_classes.html#splipy.Surface" title="splipy.Surface">Surface</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="splipy.surface_factory.sweep">
<code class="descclassname">splipy.surface_factory.</code><code class="descname">sweep</code><span class="sig-paren">(</span><em>path</em>, <em>shape</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/surface_factory.html#sweep"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.surface_factory.sweep" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a surface by sweeping a shape along a path</p>
<p>The resulting surface is an approximation generated by interpolating at the
Greville points. It is generated by sweeping a shape curve along a path.</p>
<p>The <em>shape</em> object has to be contained in the ‘xy’ plane (preferably centered
around the origin) as its x-coordinate is extruded in the normal direction,
and its y-coordinate in the binormal direction of the <em>path</em> curve.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>path</strong> (<a class="reference internal" href="basic_classes.html#splipy.Curve" title="splipy.Curve"><em>Curve</em></a>) – The path to drag <em>shape</em> along</li>
<li><strong>shape</strong> (<a class="reference internal" href="basic_classes.html#splipy.Curve" title="splipy.Curve"><em>Curve</em></a>) – The shape to be dragged out to a surface</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Surrounding surface</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="basic_classes.html#splipy.Surface" title="splipy.Surface">Surface</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="splipy.surface_factory.interpolate">
<code class="descclassname">splipy.surface_factory.</code><code class="descname">interpolate</code><span class="sig-paren">(</span><em>x</em>, <em>bases</em>, <em>u=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/surface_factory.html#interpolate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.surface_factory.interpolate" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolate a surface on a set of regular gridded interpolation points <cite>x</cite>.</p>
<p>The points can be either a matrix (in which case the first index is
interpreted as a flat row-first index of the interpolation grid) or a 3D
tensor. In both cases the last index is the physical coordinates.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>numpy.ndarray</em>) – Grid of interpolation points</li>
<li><strong>bases</strong> (<em>[</em><a class="reference internal" href="basic_classes.html#splipy.BSplineBasis" title="splipy.BSplineBasis"><em>BSplineBasis</em></a><em>]</em>) – The basis to interpolate on</li>
<li><strong>u</strong> (<em>[</em><em>array-like</em><em>]</em>) – Parametric interpolation points, defaults to
Greville points of the basis</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Interpolated surface</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="basic_classes.html#splipy.Surface" title="splipy.Surface">Surface</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="splipy.surface_factory.least_square_fit">
<code class="descclassname">splipy.surface_factory.</code><code class="descname">least_square_fit</code><span class="sig-paren">(</span><em>x</em>, <em>bases</em>, <em>u</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/surface_factory.html#least_square_fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.surface_factory.least_square_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a least-square fit of a point cloud <cite>x</cite> onto a spline basis.</p>
<p>The points can be either a matrix (in which case the first index is
interpreted as a flat row-first index of the interpolation grid) or a 3D
tensor. In both cases the last index is the physical coordinates.</p>
<p>There must be at least as many points as basis functions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>numpy.ndarray</em>) – Grid of evaluation points</li>
<li><strong>bases</strong> (<em>[</em><a class="reference internal" href="basic_classes.html#splipy.BSplineBasis" title="splipy.BSplineBasis"><em>BSplineBasis</em></a><em>]</em>) – Basis on which to interpolate</li>
<li><strong>u</strong> (<em>[</em><em>array-like</em><em>]</em>) – Parametric values at evaluation points</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Approximated surface</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="basic_classes.html#splipy.Surface" title="splipy.Surface">Surface</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="splipy.surface_factory.teapot">
<code class="descclassname">splipy.surface_factory.</code><code class="descname">teapot</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/surface_factory.html#teapot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.surface_factory.teapot" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the Utah teapot as 32 cubic bezier patches. This teapot has a
rim, but no bottom. It is also self-intersecting making it unsuitable for
perfect-match multipatch modeling.</p>
<p>The data is picked from <a class="reference external" href="http://www.holmes3d.net/graphics/teapot/">http://www.holmes3d.net/graphics/teapot/</a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The utah teapot</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">List of Surface</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-splipy.volume_factory">
<span id="volumes"></span><h2>Volumes<a class="headerlink" href="#module-splipy.volume_factory" title="Permalink to this headline">¶</a></h2>
<p>Handy utilities for creating volumes.</p>
<dl class="function">
<dt id="splipy.volume_factory.cube">
<code class="descclassname">splipy.volume_factory.</code><code class="descname">cube</code><span class="sig-paren">(</span><em>size=1</em>, <em>lower_left=(0</em>, <em>0</em>, <em>0)</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/volume_factory.html#cube"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.volume_factory.cube" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a cube with parmetric origin at <em>(0,0,0)</em>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>size</strong> (<em>float</em>) – Size(s), either a single scalar or a tuple of scalars per axis</li>
<li><strong>lower_left</strong> (<em>array-like</em>) – local origin, the lower bottom left corner of the cube</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A linear parametrized box</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="basic_classes.html#splipy.Volume" title="splipy.Volume">Volume</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="splipy.volume_factory.sphere">
<code class="descclassname">splipy.volume_factory.</code><code class="descname">sphere</code><span class="sig-paren">(</span><em>r=1</em>, <em>center=(0</em>, <em>0</em>, <em>0)</em>, <em>type='radial'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/volume_factory.html#sphere"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.volume_factory.sphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a solid sphere</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>r</strong> (<em>float</em>) – Radius</li>
<li><strong>center</strong> (<em>array-like</em>) – Local origin of the sphere</li>
<li><strong>type</strong> (<em>string</em>) – The type of parametrization (‘radial’ or ‘square’)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A solid ball</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="basic_classes.html#splipy.Volume" title="splipy.Volume">Volume</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="splipy.volume_factory.revolve">
<code class="descclassname">splipy.volume_factory.</code><code class="descname">revolve</code><span class="sig-paren">(</span><em>surf</em>, <em>theta=6.283185307179586</em>, <em>axis=(0</em>, <em>0</em>, <em>1)</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/volume_factory.html#revolve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.volume_factory.revolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Revolve a volume by sweeping a surface in a rotational fashion around
an axis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>surf</strong> (<a class="reference internal" href="basic_classes.html#splipy.Surface" title="splipy.Surface"><em>Surface</em></a>) – Surface to revolve</li>
<li><strong>theta</strong> (<em>float</em>) – Angle to revolve, in radians</li>
<li><strong>axis</strong> (<em>array-like</em>) – Axis of rotation</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The revolved surface</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="basic_classes.html#splipy.Volume" title="splipy.Volume">Volume</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="splipy.volume_factory.cylinder">
<code class="descclassname">splipy.volume_factory.</code><code class="descname">cylinder</code><span class="sig-paren">(</span><em>r=1</em>, <em>h=1</em>, <em>center=(0</em>, <em>0</em>, <em>0)</em>, <em>axis=(0</em>, <em>0</em>, <em>1)</em>, <em>xaxis=(1</em>, <em>0</em>, <em>0)</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/volume_factory.html#cylinder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.volume_factory.cylinder" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a solid cylinder</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>r</strong> (<em>float</em>) – Radius</li>
<li><strong>h</strong> (<em>float</em>) – Height</li>
<li><strong>center</strong> (<em>array-like</em>) – The center of the bottom circle</li>
<li><strong>axis</strong> (<em>array-like</em>) – Cylinder axis</li>
<li><strong>xaxis</strong> (<em>array-like</em>) – direction of sem, i.e. parametric start point u=0</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The cylinder</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="basic_classes.html#splipy.Volume" title="splipy.Volume">Volume</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="splipy.volume_factory.extrude">
<code class="descclassname">splipy.volume_factory.</code><code class="descname">extrude</code><span class="sig-paren">(</span><em>surf</em>, <em>amount</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/volume_factory.html#extrude"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.volume_factory.extrude" title="Permalink to this definition">¶</a></dt>
<dd><p>Extrude a surface by sweeping it to a given height.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>surf</strong> (<a class="reference internal" href="basic_classes.html#splipy.Surface" title="splipy.Surface"><em>Surface</em></a>) – Surface to extrude</li>
<li><strong>amount</strong> (<em>array-like</em>) – 3-component vector of sweeping amount and direction</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The extruded surface</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="basic_classes.html#splipy.Volume" title="splipy.Volume">Volume</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="splipy.volume_factory.edge_surfaces">
<code class="descclassname">splipy.volume_factory.</code><code class="descname">edge_surfaces</code><span class="sig-paren">(</span><em>*surfaces</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/volume_factory.html#edge_surfaces"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.volume_factory.edge_surfaces" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the volume defined by the region between the input surfaces.</p>
<p>In case of six input surfaces, these must be given in the order: bottom,
top, left, right, back, front. Opposing sides must be parametrized in the
same directions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>surfaces</strong> (<em>[</em><a class="reference internal" href="basic_classes.html#splipy.Surface" title="splipy.Surface"><em>Surface</em></a><em>]</em>) – Two or six edge surfaces</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The enclosed volume</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="basic_classes.html#splipy.Volume" title="splipy.Volume">Volume</a></td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><strong>ValueError</strong> – If the length of <em>surfaces</em> is not two or six</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="splipy.volume_factory.interpolate">
<code class="descclassname">splipy.volume_factory.</code><code class="descname">interpolate</code><span class="sig-paren">(</span><em>x</em>, <em>bases</em>, <em>u=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/volume_factory.html#interpolate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.volume_factory.interpolate" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolate a volume on a set of regular gridded interpolation points <cite>x</cite>.</p>
<p>The points can be either a matrix (in which case the first index is
interpreted as a flat row-first index of the interpolation grid) or a 4D
tensor. In both cases the last index is the physical coordinates.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>numpy.ndarray</em>) – Grid of interpolation points</li>
<li><strong>bases</strong> (<em>[</em><a class="reference internal" href="basic_classes.html#splipy.BSplineBasis" title="splipy.BSplineBasis"><em>BSplineBasis</em></a><em>]</em>) – The basis to interpolate on</li>
<li><strong>u</strong> (<em>[</em><em>array-like</em><em>]</em>) – Parametric interpolation points, defaults to
Greville points of the basis</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Interpolated volume</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="basic_classes.html#splipy.Volume" title="splipy.Volume">Volume</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="splipy.volume_factory.least_square_fit">
<code class="descclassname">splipy.volume_factory.</code><code class="descname">least_square_fit</code><span class="sig-paren">(</span><em>x</em>, <em>bases</em>, <em>u</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/volume_factory.html#least_square_fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.volume_factory.least_square_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a least-square fit of a point cloud <cite>x</cite> onto a spline basis.</p>
<p>The points can be either a matrix (in which case the first index is
interpreted as a flat row-first index of the interpolation grid) or a 4D
tensor. In both cases the last index is the physical coordinates.</p>
<p>There must be at least as many points as basis functions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>numpy.ndarray</em>) – Grid of evaluation points</li>
<li><strong>bases</strong> (<em>[</em><a class="reference internal" href="basic_classes.html#splipy.BSplineBasis" title="splipy.BSplineBasis"><em>BSplineBasis</em></a><em>]</em>) – Basis on which to interpolate</li>
<li><strong>u</strong> (<em>[</em><em>array-like</em><em>]</em>) – Parametric values at evaluation points</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Approximated volume</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="basic_classes.html#splipy.Volume" title="splipy.Volume">Volume</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Factories</a><ul>
<li><a class="reference internal" href="#module-splipy.curve_factory">Curves</a></li>
<li><a class="reference internal" href="#module-splipy.surface_factory">Surfaces</a></li>
<li><a class="reference internal" href="#module-splipy.volume_factory">Volumes</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/factories.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Splipy 1.2.0 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, Arne Morten Kvarving, Kjetil Andre Johannessen, Eivind Fonn.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.1.
    </div>
  </body>
</html>