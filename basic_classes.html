
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Basic classes &#8212; Splipy 1.2.0 documentation</title>
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Splipy 1.2.0 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="basic-classes">
<h1>Basic classes<a class="headerlink" href="#basic-classes" title="Permalink to this headline">¶</a></h1>
<div class="section" id="bsplinebasis">
<h2>BSplineBasis<a class="headerlink" href="#bsplinebasis" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="splipy.BSplineBasis">
<em class="property">class </em><code class="descclassname">splipy.</code><code class="descname">BSplineBasis</code><a class="reference internal" href="_modules/splipy/BSplineBasis.html#BSplineBasis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.BSplineBasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents a one-dimensional B-Spline basis.</p>
<p>BSplineBasis objects support basic arithmetic operators, which are
interpreted as acting on the parametric domain.</p>
<dl class="method">
<dt id="splipy.BSplineBasis.__getitem__">
<code class="descname">__getitem__</code><span class="sig-paren">(</span><em>i</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/BSplineBasis.html#BSplineBasis.__getitem__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.BSplineBasis.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the knot at a given index.</p>
</dd></dl>

<dl class="method">
<dt id="splipy.BSplineBasis.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>order=2</em>, <em>knots=None</em>, <em>periodic=-1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/BSplineBasis.html#BSplineBasis.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.BSplineBasis.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a B-Spline basis with a given order and knot vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>order</strong> (<em>int</em>) – Spline order, i.e. one greater than the polynomial degree.</li>
<li><strong>knots</strong> (<em>[</em><em>float</em><em>]</em>) – Knot vector of non-decreasing components.
Defaults to open knot vector on domain [0,1].</li>
<li><strong>periodic</strong> (<em>int</em>) – Number of continuous derivatives at start and end.
–1 is not periodic, 0 is continuous, etc.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><strong>ValueError</strong> – for inapproriate knot vectors</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.BSplineBasis.__len__">
<code class="descname">__len__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/BSplineBasis.html#BSplineBasis.__len__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.BSplineBasis.__len__" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of knots in this basis.</p>
</dd></dl>

<dl class="method">
<dt id="splipy.BSplineBasis.clone">
<code class="descname">clone</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/BSplineBasis.html#BSplineBasis.clone"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.BSplineBasis.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Clone the object.</p>
</dd></dl>

<dl class="method">
<dt id="splipy.BSplineBasis.continuity">
<code class="descname">continuity</code><span class="sig-paren">(</span><em>knot</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/BSplineBasis.html#BSplineBasis.continuity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.BSplineBasis.continuity" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the continuity of the basis functions at a given point.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><em>p</em>–<em>m</em>–1 at a knot with multiplicity <em>m</em>, or <code class="docutils literal notranslate"><span class="pre">inf</span></code>
between knots.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">int or float</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.BSplineBasis.end">
<code class="descname">end</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/BSplineBasis.html#BSplineBasis.end"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.BSplineBasis.end" title="Permalink to this definition">¶</a></dt>
<dd><p>End point of parametric domain. For open knot vectors, this is the
last knot.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Knot number <em>n</em>–<em>p</em>, where <em>p</em> is the spline order and <em>n</em> is
the number of knots</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">Float</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.BSplineBasis.evaluate">
<code class="descname">evaluate</code><span class="sig-paren">(</span><em>t</em>, <em>d=0</em>, <em>from_right=True</em>, <em>sparse=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/BSplineBasis.html#BSplineBasis.evaluate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.BSplineBasis.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate all basis functions in a given set of points.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>t</strong> (<em>float</em><em> or </em><em>[</em><em>float</em><em>]</em>) – The parametric coordinate(s) in which to evaluate</li>
<li><strong>d</strong> (<em>int</em>) – Number of derivatives to compute</li>
<li><strong>from_right</strong> (<em>bool</em>) – True if evaluation should be done in the limit
from above</li>
<li><strong>sparse</strong> (<em>bool</em>) – True if computed matrix should be returned as sparse</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A matrix <em>N[i,j]</em> of all basis functions <em>j</em> evaluated in all
points <em>i</em></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy.array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.BSplineBasis.evaluate_old">
<code class="descname">evaluate_old</code><span class="sig-paren">(</span><em>t</em>, <em>d=0</em>, <em>from_right=True</em>, <em>sparse=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/BSplineBasis.html#BSplineBasis.evaluate_old"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.BSplineBasis.evaluate_old" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate all basis functions in a given set of points.
:param t: The parametric coordinate(s) in which to evaluate
:type t: float or [float]
:param int d: Number of derivatives to compute
:param bool from_right: True if evaluation should be done in the limit</p>
<blockquote>
<div>from above</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>sparse</strong> (<em>bool</em>) – True if computed matrix should be returned as sparse</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A matrix <em>N[i,j]</em> of all basis functions <em>j</em> evaluated in all
points <em>i</em></td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">numpy.array</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.BSplineBasis.greville">
<code class="descname">greville</code><span class="sig-paren">(</span><em>index=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/BSplineBasis.html#BSplineBasis.greville"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.BSplineBasis.greville" title="Permalink to this definition">¶</a></dt>
<dd><p>Fetch greville points, also known as knot averages:</p>
<div class="math notranslate">
\[\sum_{j=i+1}^{i+p-1} \frac{t_j}{p-1}\]</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">One, or all of the Greville points</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">[float] (if <em>index</em> is <code class="docutils literal notranslate"><span class="pre">None</span></code>) or float</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.BSplineBasis.insert_knot">
<code class="descname">insert_knot</code><span class="sig-paren">(</span><em>new_knot</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/BSplineBasis.html#BSplineBasis.insert_knot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.BSplineBasis.insert_knot" title="Permalink to this definition">¶</a></dt>
<dd><p>Inserts a knot in the knot vector.</p>
<p>The return value is a sparse matrix <em>C</em> (actually, a dense matrix with
lots of zeros), such that <em>N_new</em> = <em>N_old</em> x <em>C</em>, where <em>N</em> are row
vectors of basis functions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>new_knot</strong> (<em>float</em>) – The parametric coordinate of the point to insert</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Transformation matrix <em>C</em></td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">numpy.array</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><strong>ValueError</strong> – If the new knot is outside the domain</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.BSplineBasis.integrate">
<code class="descname">integrate</code><span class="sig-paren">(</span><em>t0</em>, <em>t1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/BSplineBasis.html#BSplineBasis.integrate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.BSplineBasis.integrate" title="Permalink to this definition">¶</a></dt>
<dd><p>Integrate all basis functions over a given domain</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>t0</strong> (<em>float</em>) – The parametric starting point</li>
<li><strong>t1</strong> (<em>float</em>) – The parametric end point</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The integration of all functions over the input domain</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">list</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.BSplineBasis.knot_spans">
<code class="descname">knot_spans</code><span class="sig-paren">(</span><em>include_ghost_knots=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/BSplineBasis.html#BSplineBasis.knot_spans"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.BSplineBasis.knot_spans" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the set of unique knots in the knot vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>include_ghost_knots</strong> (<em>bool</em>) – if knots outside start/end are to be
included. These knots are used by periodic basis.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">List of unique knots</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">[float]</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.BSplineBasis.lower_order">
<code class="descname">lower_order</code><span class="sig-paren">(</span><em>amount</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/BSplineBasis.html#BSplineBasis.lower_order"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.BSplineBasis.lower_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a knot vector with lower order.</p>
<p>The continuity at the knots are kept unchanged by decreasing their
multiplicities.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">New knot vector</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">[float]</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><strong>TypeError</strong> – If <cite>amount</cite> is not an int</li>
<li><strong>ValueError</strong> – If <cite>amount</cite> is negative</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.BSplineBasis.make_periodic">
<code class="descname">make_periodic</code><span class="sig-paren">(</span><em>continuity</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/BSplineBasis.html#BSplineBasis.make_periodic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.BSplineBasis.make_periodic" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a periodic basis with a given continuity.</p>
</dd></dl>

<dl class="method">
<dt id="splipy.BSplineBasis.matches">
<code class="descname">matches</code><span class="sig-paren">(</span><em>bspline</em>, <em>reverse=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/BSplineBasis.html#BSplineBasis.matches"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.BSplineBasis.matches" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if this basis equals another basis, when disregarding
scaling and translation of the knots vector. I.e. will this basis and
<em>bspline</em> yield the same spline object if paired with identical
controlpoints</p>
</dd></dl>

<dl class="method">
<dt id="splipy.BSplineBasis.normalize">
<code class="descname">normalize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/BSplineBasis.html#BSplineBasis.normalize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.BSplineBasis.normalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the parametric domain to be (0,1).</p>
</dd></dl>

<dl class="method">
<dt id="splipy.BSplineBasis.num_functions">
<code class="descname">num_functions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/BSplineBasis.html#BSplineBasis.num_functions"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.BSplineBasis.num_functions" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of basis functions in the basis.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This is different from <a class="reference internal" href="#splipy.BSplineBasis.__len__" title="splipy.BSplineBasis.__len__"><code class="xref py py-func docutils literal notranslate"><span class="pre">splipy.BSplineBasis.__len__()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="splipy.BSplineBasis.raise_order">
<code class="descname">raise_order</code><span class="sig-paren">(</span><em>amount</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/BSplineBasis.html#BSplineBasis.raise_order"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.BSplineBasis.raise_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a knot vector with higher order.</p>
<p>The continuity at the knots are kept unchanged by increasing their
multiplicities.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">New knot vector</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">[float]</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><strong>TypeError</strong> – If <cite>amount</cite> is not an int</li>
<li><strong>ValueError</strong> – If <cite>amount</cite> is negative</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.BSplineBasis.reparam">
<code class="descname">reparam</code><span class="sig-paren">(</span><em>start=0</em>, <em>end=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/BSplineBasis.html#BSplineBasis.reparam"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.BSplineBasis.reparam" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the parametric domain to be (start, end)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><strong>ValueError</strong> – If <em>end</em> ≤ <em>start</em></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.BSplineBasis.reverse">
<code class="descname">reverse</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/BSplineBasis.html#BSplineBasis.reverse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.BSplineBasis.reverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverse parametric domain, keeping start/end values unchanged.</p>
</dd></dl>

<dl class="method">
<dt id="splipy.BSplineBasis.roll">
<code class="descname">roll</code><span class="sig-paren">(</span><em>new_start</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/BSplineBasis.html#BSplineBasis.roll"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.BSplineBasis.roll" title="Permalink to this definition">¶</a></dt>
<dd><p>rotate a periodic knot vector by setting a new starting index.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>new_start</strong> (<em>int</em>) – The index of to the new first knot</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.BSplineBasis.snap">
<code class="descname">snap</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/BSplineBasis.html#BSplineBasis.snap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.BSplineBasis.snap" title="Permalink to this definition">¶</a></dt>
<dd><p>Snap evaluation points to knots if they are sufficiently close
as given in by state.state.knot_tolerance. This will modify the input vector t</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>t</strong> (<em>[</em><em>float</em><em>]</em>) – evaluation points</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">none</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.BSplineBasis.start">
<code class="descname">start</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/BSplineBasis.html#BSplineBasis.start"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.BSplineBasis.start" title="Permalink to this definition">¶</a></dt>
<dd><p>Start point of parametric domain. For open knot vectors, this is the
first knot.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Knot number <em>p</em>, where <em>p</em> is the spline order</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">float</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="splineobject">
<h2>SplineObject<a class="headerlink" href="#splineobject" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="splipy.SplineObject">
<em class="property">class </em><code class="descclassname">splipy.</code><code class="descname">SplineObject</code><span class="sig-paren">(</span><em>bases=None</em>, <em>controlpoints=None</em>, <em>rational=False</em>, <em>raw=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/SplineObject.html#SplineObject"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.SplineObject" title="Permalink to this definition">¶</a></dt>
<dd><p>Master class for spline objects with arbitrary dimensions.</p>
<p>This class should be subclassed instead of used directly.</p>
<p>All SplineObjects support basic arithmetic operators, which are interpreted
as translation and scaling. In-place operators (e.g. <code class="docutils literal notranslate"><span class="pre">+=</span></code>) mutate the
object, while infix operators (e.g. <code class="docutils literal notranslate"><span class="pre">+</span></code>) create new objects.</p>
<dl class="method">
<dt id="splipy.SplineObject.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>bases=None</em>, <em>controlpoints=None</em>, <em>rational=False</em>, <em>raw=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/SplineObject.html#SplineObject.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.SplineObject.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a spline object with the given bases and control points.</p>
<p>The default is to create a linear one-element mapping from and to the
unit (hyper)cube.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>bases</strong> (<em>[</em><a class="reference internal" href="#splipy.BSplineBasis" title="splipy.BSplineBasis"><em>BSplineBasis</em></a><em>]</em>) – The basis of each parameter direction</li>
<li><strong>controlpoints</strong> (<em>array-like</em>) – An <em>n1</em> × <em>n2</em> × … × <em>d</em> matrix of
control points</li>
<li><strong>rational</strong> (<em>bool</em>) – Whether the object is rational (in which case the
control points are interpreted as pre-multiplied with the weight,
which is the last coordinate)</li>
<li><strong>raw</strong> (<em>bool</em>) – If True, skip any control point reordering.
(For internal use.)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.SplineObject.bounding_box">
<code class="descname">bounding_box</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/SplineObject.html#SplineObject.bounding_box"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.SplineObject.bounding_box" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the bounding box of a spline object, computed from the
control-point values. Could be inaccurate for rational splines.</p>
<p>Returns the minima and maxima for each direction:
[(xmin, xmax), (ymin, ymax), …]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Bounding box</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">[(float)]</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.SplineObject.center">
<code class="descname">center</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/SplineObject.html#SplineObject.center"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.SplineObject.center" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the center of the domain</p>
<p>For curves this will return <span class="math notranslate">\((\tilde{x}, \tilde{y},...)\)</span>, where</p>
<div class="math notranslate">
\[\tilde{x} = \frac{1}{L} \int_{t_0}^{t_1} x(t) \; dt\]</div>
<p>and <span class="math notranslate">\(L=t_1-t_0\)</span> is the length of the parametric domain <span class="math notranslate">\([t_0,t_1]\)</span>.</p>
<p>For surfaces this will return <span class="math notranslate">\((\tilde{x}, \tilde{y},...)\)</span>, where</p>
<div class="math notranslate">
\[\tilde{x} = \frac{1}{A} \int_{v_0}^{v_1} \int_{u_0}^{u_1} x(u,v) \; du \; dv\]</div>
<p>and <span class="math notranslate">\(A=(u_1-u_0)(v_1-v_0)\)</span> is the area of the parametric domain <span class="math notranslate">\([u_0,u_1]\times[v_0,v_1]\)</span>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">For rational splines, this will integrate in projective
coordinates, then project the centerpoint. This is as opposed to
integrating the rational functions <span class="math notranslate">\(\frac{N_i(t)w_i}{\sum_j
N_j(t)w_j}\)</span>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="splipy.SplineObject.clone">
<code class="descname">clone</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/SplineObject.html#SplineObject.clone"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.SplineObject.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Clone the object.</p>
</dd></dl>

<dl class="method">
<dt id="splipy.SplineObject.corners">
<code class="descname">corners</code><span class="sig-paren">(</span><em>order='C'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/SplineObject.html#SplineObject.corners"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.SplineObject.corners" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the corner control points.</p>
<p>The <cite>order</cite> parameter determines which order to use, either <code class="docutils literal notranslate"><span class="pre">'F'</span></code> or
<code class="docutils literal notranslate"><span class="pre">'C'</span></code>, for row-major or column-major ordering. E.g. for a volume, in
parametric coordinates,</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">'C'</span></code> gives (0,0,0), (1,0,0), (0,1,0), (1,1,0), (0,0,1), etc.</li>
<li><code class="docutils literal notranslate"><span class="pre">'F'</span></code> gives (0,0,0), (0,0,1), (0,1,0), (0,1,1), (1,0,0), etc.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>order</strong> (<em>str</em>) – The ordering to use</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Corners</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">np.array</td>
</tr>
</tbody>
</table>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">For rational splines, this will return the corners in
projective coordinates, including weights.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="splipy.SplineObject.derivative">
<code class="descname">derivative</code><span class="sig-paren">(</span><em>*params</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/SplineObject.html#SplineObject.derivative"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.SplineObject.derivative" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the derivative of the object at the given parametric values.</p>
<p>If <em>tensor</em> is true, evaluation will take place on a tensor product
grid, i.e. it will return an <em>n1</em> × <em>n2</em> × … × <em>dim</em> array, where
<em>ni</em> is the number of evaluation points in direction <em>i</em>, and <em>dim</em> is
the physical dimension of the object.</p>
<p>If <em>tensor</em> is false, there must be an equal number <em>n</em> of evaluation
points in all directions, and the return value will be an <em>n</em> × <em>dim</em>
array.</p>
<p>If there is only one evaluation point, a vector of length <em>dim</em> is
returned instead.</p>
<p>Examples:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Tangent of curve at single point</span>
<span class="n">curve</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>

<span class="c1"># Double derivative of curve at single point:</span>
<span class="n">curve</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># Third derivative of curve at several points:</span>
<span class="n">curve</span><span class="o">.</span><span class="n">derivative</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> <span class="n">d</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

<span class="c1"># Tangents of surface:</span>
<span class="n">surface</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
<span class="n">surface</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>

<span class="c1"># Cross-derivative of surface:</span>
<span class="n">surface</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>u</strong><strong>,</strong><strong>v</strong><strong>,</strong><strong>..</strong> (<em>float</em><em> or </em><em>[</em><em>float</em><em>]</em>) – Parametric coordinates in which to evaluate</li>
<li><strong>d</strong> (<em>(</em><em>int</em><em>)</em>) – Order of derivative to compute</li>
<li><strong>above</strong> (<em>(</em><em>bool</em><em>)</em>) – Evaluation in the limit from above</li>
<li><strong>tensor</strong> (<em>bool</em>) – Whether to evaluate on a tensor product grid</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Derivatives</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy.array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.SplineObject.end">
<code class="descname">end</code><span class="sig-paren">(</span><em>direction=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/SplineObject.html#SplineObject.end"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.SplineObject.end" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the end of the parametric domain.</p>
<p>If <cite>direction</cite> is given, returns the end of that direction, as a float.
If it is not given, returns the end of all directions, as a tuple.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>direction</strong> (<em>int</em>) – Direction in which to get the end.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><strong>ValueError</strong> – For invalid direction</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.SplineObject.evaluate">
<code class="descname">evaluate</code><span class="sig-paren">(</span><em>*params</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/SplineObject.html#SplineObject.evaluate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.SplineObject.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the object at given parametric values.</p>
<p>If <em>tensor</em> is true, evaluation will take place on a tensor product
grid, i.e. it will return an <em>n1</em> × <em>n2</em> × … × <em>dim</em> array, where
<em>ni</em> is the number of evaluation points in direction <em>i</em>, and <em>dim</em> is
the physical dimension of the object.</p>
<p>If <em>tensor</em> is false, there must be an equal number <em>n</em> of evaluation
points in all directions, and the return value will be an <em>n</em> × <em>dim</em>
array.</p>
<p>If there is only one evaluation point, a vector of length <em>dim</em> is
returned instead.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>u</strong><strong>,</strong><strong>v</strong><strong>,</strong><strong>..</strong> (<em>float</em><em> or </em><em>[</em><em>float</em><em>]</em>) – Parametric coordinates in which to evaluate</li>
<li><strong>tensor</strong> (<em>bool</em>) – Whether to evaluate on a tensor product grid</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Geometry coordinates</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy.array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.SplineObject.force_rational">
<code class="descname">force_rational</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/SplineObject.html#SplineObject.force_rational"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.SplineObject.force_rational" title="Permalink to this definition">¶</a></dt>
<dd><p>Force a rational representation of the object.</p>
<p>The weights of a non-rational object will be set to 1.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">self</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.SplineObject.get_derivative_spline">
<code class="descname">get_derivative_spline</code><span class="sig-paren">(</span><em>direction=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/SplineObject.html#SplineObject.get_derivative_spline"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.SplineObject.get_derivative_spline" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the controlpoints associated with the derivative spline object</p>
<p>If <cite>direction</cite> is given, only the derivatives in that direction are
returned.</p>
<p>If <cite>direction</cite> is not given, this function returns a tuple of all
partial derivatives</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create a 4x4 element cubic spline surface</span>
<span class="n">surf</span> <span class="o">=</span> <span class="n">Surface</span><span class="p">()</span>
<span class="n">surf</span><span class="o">.</span><span class="n">raise_order</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">surf</span><span class="o">.</span><span class="n">refine</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="n">surf</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">,:]</span> <span class="o">+=</span> <span class="mf">0.1</span> <span class="c1"># make the surface non-trivial by moving controlpoints</span>

<span class="c1"># Create the derivative surface</span>
<span class="n">du</span> <span class="o">=</span> <span class="n">surf</span><span class="o">.</span><span class="n">get_derivative_spline</span><span class="p">(</span><span class="n">direction</span><span class="o">=</span><span class="s1">&#39;u&#39;</span><span class="p">)</span>

<span class="c1"># evaluation is identical</span>
<span class="nb">print</span><span class="p">(</span><span class="n">du</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">surf</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)))</span>

<span class="nb">print</span><span class="p">(</span><span class="n">surf</span><span class="o">.</span><span class="n">order</span><span class="p">())</span> <span class="c1"># prints (3,3)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">du</span><span class="o">.</span><span class="n">order</span><span class="p">())</span>   <span class="c1"># prints (2,3)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>direction</strong> (<em>int</em>) – The tangential direction</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Derivative spline</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#splipy.SplineObject" title="splipy.SplineObject">SplineObject</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.SplineObject.insert_knot">
<code class="descname">insert_knot</code><span class="sig-paren">(</span><em>knot</em>, <em>direction=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/SplineObject.html#SplineObject.insert_knot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.SplineObject.insert_knot" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert a new knot into the spline.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>direction</strong> (<em>int</em>) – The direction to insert in</li>
<li><strong>knot</strong> (<em>float</em><em> or </em><em>[</em><em>float</em><em>]</em>) – The new knot(s) to insert</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>ValueError</strong> – For invalid direction</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">self</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.SplineObject.knots">
<code class="descname">knots</code><span class="sig-paren">(</span><em>direction=None</em>, <em>with_multiplicities=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/SplineObject.html#SplineObject.knots"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.SplineObject.knots" title="Permalink to this definition">¶</a></dt>
<dd><p>Return knots vector</p>
<p>If <cite>direction</cite> is given, returns the knots in that direction, as a
list. If it is not given, returns the knots of all directions, as a
tuple.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>direction</strong> (<em>int</em>) – Direction in which to get the knots.</li>
<li><strong>with_multiplicities</strong> (<em>bool</em>) – If true, return knots with
multiplicities (i.e. repeated).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><strong>ValueError</strong> – For invalid direction</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.SplineObject.lower_order">
<code class="descname">lower_order</code><span class="sig-paren">(</span><em>*lowers</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/SplineObject.html#SplineObject.lower_order"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.SplineObject.lower_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Lower the polynomial order of the object. If only one argument is
given, the order is lowered equally over all directions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>u</strong><strong>,</strong><strong>v</strong><strong>,</strong><strong>..</strong> (<em>int</em>) – Number of times to lower the order in a given
direction.</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Return SplineObject:</th></tr>
<tr class="field-even field"><td>&#160;</td><td class="field-body">Approximation of the current object on a lower
order basis</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.SplineObject.lower_periodic">
<code class="descname">lower_periodic</code><span class="sig-paren">(</span><em>periodic</em>, <em>direction=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/SplineObject.html#SplineObject.lower_periodic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.SplineObject.lower_periodic" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the periodicity of the spline object in the given direction,
keeping the geometry unchanged.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>periodic</strong> (<em>int</em>) – new periodicity, i.e. the basis is C^k over the start/end</li>
<li><strong>direction</strong> (<em>int</em>) – the parametric direction of the basis to modify</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">self</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.SplineObject.make_periodic">
<code class="descname">make_periodic</code><span class="sig-paren">(</span><em>continuity=None</em>, <em>direction=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/SplineObject.html#SplineObject.make_periodic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.SplineObject.make_periodic" title="Permalink to this definition">¶</a></dt>
<dd><p>Make the spline object periodic in a given parametric direction.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>continuity</strong> (<em>int</em>) – The continuity along the boundary (default max).</li>
<li><strong>direction</strong> (<em>int</em>) – The direction to ensure continuity in.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="splipy.SplineObject.make_splines_compatible">
<em class="property">classmethod </em><code class="descname">make_splines_compatible</code><span class="sig-paren">(</span><em>spline1</em>, <em>spline2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/SplineObject.html#SplineObject.make_splines_compatible"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.SplineObject.make_splines_compatible" title="Permalink to this definition">¶</a></dt>
<dd><p>Ensure that two splines are compatible.</p>
<p>This will manipulate one or both to ensure that they are both rational
or nonrational, and that they lie in the same physical space.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>spline1</strong> (<a class="reference internal" href="#splipy.SplineObject" title="splipy.SplineObject"><em>SplineObject</em></a>) – The first spline</li>
<li><strong>spline2</strong> (<a class="reference internal" href="#splipy.SplineObject" title="splipy.SplineObject"><em>SplineObject</em></a>) – The second spline</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="splipy.SplineObject.make_splines_identical">
<em class="property">classmethod </em><code class="descname">make_splines_identical</code><span class="sig-paren">(</span><em>spline1</em>, <em>spline2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/SplineObject.html#SplineObject.make_splines_identical"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.SplineObject.make_splines_identical" title="Permalink to this definition">¶</a></dt>
<dd><p>Ensure that two splines have identical discretization.</p>
<p>This will first make them compatible (see
<code class="xref py py-func docutils literal notranslate"><span class="pre">splipy.SplineObject.make_curves_compatible()</span></code>), reparametrize them, and
possibly raise the order and insert knots as required.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>spline1</strong> (<a class="reference internal" href="#splipy.SplineObject" title="splipy.SplineObject"><em>SplineObject</em></a>) – The first spline</li>
<li><strong>spline2</strong> (<a class="reference internal" href="#splipy.SplineObject" title="splipy.SplineObject"><em>SplineObject</em></a>) – The second spline</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.SplineObject.mirror">
<code class="descname">mirror</code><span class="sig-paren">(</span><em>normal</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/SplineObject.html#SplineObject.mirror"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.SplineObject.mirror" title="Permalink to this definition">¶</a></dt>
<dd><p>Mirror the object around a plane through the origin.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>normal</strong> (<em>array-like</em>) – The plane normal to mirror about.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><strong>RuntimeError</strong> – If the physical dimension is not 2 or 3</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">self</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.SplineObject.order">
<code class="descname">order</code><span class="sig-paren">(</span><em>direction=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/SplineObject.html#SplineObject.order"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.SplineObject.order" title="Permalink to this definition">¶</a></dt>
<dd><p>Return polynomial order (degree + 1).</p>
<p>If <cite>direction</cite> is given, returns the order of that direction, as an
int. If it is not given, returns the order of all directions, as a
tuple.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>direction</strong> (<em>int</em>) – Direction in which to get the order.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><strong>ValueError</strong> – For invalid direction</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="splipy.SplineObject.pardim">
<code class="descname">pardim</code><a class="headerlink" href="#splipy.SplineObject.pardim" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of parametric dimensions: 1 for curves, 2 for surfaces, 3
for volumes, etc.</p>
</dd></dl>

<dl class="method">
<dt id="splipy.SplineObject.periodic">
<code class="descname">periodic</code><span class="sig-paren">(</span><em>direction=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/SplineObject.html#SplineObject.periodic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.SplineObject.periodic" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if the spline object is periodic in the given parametric direction</p>
</dd></dl>

<dl class="method">
<dt id="splipy.SplineObject.project">
<code class="descname">project</code><span class="sig-paren">(</span><em>plane</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/SplineObject.html#SplineObject.project"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.SplineObject.project" title="Permalink to this definition">¶</a></dt>
<dd><p>Projects the geometry onto a plane or axis.</p>
<ul class="simple">
<li><cite>project(‘xy’)</cite> will project the object onto the <em>xy</em> plane, setting
all <em>z</em> components to zero.</li>
<li><cite>project(‘y’)</cite> will project the object onto the <em>y</em> axis, setting all
<em>x</em> and <em>z</em> components to zero.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>plane</strong> (<em>string</em>) – Any combination of ‘x’, ‘y’ and ‘z’</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">self</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.SplineObject.raise_order">
<code class="descname">raise_order</code><span class="sig-paren">(</span><em>*raises</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/SplineObject.html#SplineObject.raise_order"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.SplineObject.raise_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Raise the polynomial order of the object. If only one argument is
given, the order is raised equally over all directions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>u</strong><strong>,</strong><strong>v</strong><strong>,</strong><strong>..</strong> (<em>int</em>) – Number of times to raise the order in a given
direction.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">self</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.SplineObject.refine">
<code class="descname">refine</code><span class="sig-paren">(</span><em>*ns</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/SplineObject.html#SplineObject.refine"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.SplineObject.refine" title="Permalink to this definition">¶</a></dt>
<dd><p>Enrich the spline space by inserting knots into each existing knot
span.</p>
<p>This method supports three different usage patterns:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Refine each direction by a factor n</span>
<span class="n">obj</span><span class="o">.</span><span class="n">refine</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

<span class="c1"># Refine a single direction by a factor n</span>
<span class="n">obj</span><span class="o">.</span><span class="n">refine</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;v&#39;</span><span class="p">)</span>

<span class="c1"># Refine all directions by given factors</span>
<span class="n">obj</span><span class="o">.</span><span class="n">refine</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">nv</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>nu</strong><strong>,</strong><strong>nv</strong><strong>,</strong><strong>..</strong> (<em>int</em>) – Number of new knots to insert into each span</li>
<li><strong>direction</strong> (<em>int</em>) – Direction to refine in</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">self</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.SplineObject.reparam">
<code class="descname">reparam</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/SplineObject.html#SplineObject.reparam"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.SplineObject.reparam" title="Permalink to this definition">¶</a></dt>
<dd><p>Redefine the parametric domain. This function accepts two calling
conventions:</p>
<p><cite>reparametrize(u, v, …)</cite> reparametrizes each direction to the domains
given by the tuples <em>u</em>, <em>v</em>, etc. It is equivalent to calling
<cite>reparametrize(u[0], u[1])</cite> on each basis. The default domain for
directions not given is (0,1). In particular, if no arguments are
given, the new parametric domain will be the unit (hyper)cube.</p>
<p><cite>reparametrize(u, direction=d)</cite> reparametrizes just the direction given
by <em>d</em> and leaves the others untouched.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>u</strong><strong>, </strong><strong>v</strong><strong>, </strong><strong>..</strong> (<em>tuple</em>) – New parametric domains, default to (0,1)</li>
<li><strong>direction</strong> (<em>int</em>) – The direction to reparametrize</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">self</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.SplineObject.reverse">
<code class="descname">reverse</code><span class="sig-paren">(</span><em>direction=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/SplineObject.html#SplineObject.reverse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.SplineObject.reverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Swap the direction of a parameter by making it go in the reverse
direction. The parametric domain remains unchanged.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>direction</strong> (<em>int</em>) – The direction to flip.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">self</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.SplineObject.rotate">
<code class="descname">rotate</code><span class="sig-paren">(</span><em>theta</em>, <em>normal=(0</em>, <em>0</em>, <em>1)</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/SplineObject.html#SplineObject.rotate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.SplineObject.rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate the object around an axis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>theta</strong> (<em>float</em>) – Angle to rotate about, measured in radians</li>
<li><strong>normal</strong> (<em>array-like</em>) – The normal axis (if 3D) to rotate about</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>RuntimeError</strong> – If the physical dimension is not 2 or 3</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">self</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.SplineObject.scale">
<code class="descname">scale</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/SplineObject.html#SplineObject.scale"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.SplineObject.scale" title="Permalink to this definition">¶</a></dt>
<dd><p>Scale, or magnify the object by a given amount.</p>
<p>In case of one input argument, the scaling is uniform.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>args</strong> (<em>array-like</em><em> or </em><em>float</em>) – Scaling factors, possibly different in each direction.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">self</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.SplineObject.section">
<code class="descname">section</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/SplineObject.html#SplineObject.section"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.SplineObject.section" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a section from the object. A section can be any sub-object of
parametric dimension not exceeding that of the object. E.g. for a
volume, sections include vertices, edges, faces, etc.</p>
<p>The arguments are control point indices for each direction. <cite>None</cite>
means that direction should be variable in the returned object.</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Get the face with u=max</span>
<span class="n">vol</span><span class="o">.</span><span class="n">section</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

<span class="c1"># Keyword arguments are supported for u, v and w</span>
<span class="c1"># This is the same as the above</span>
<span class="n">vol</span><span class="o">.</span><span class="n">section</span><span class="p">(</span><span class="n">u</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Get the edge with u=min, v=max</span>
<span class="n">vol</span><span class="o">.</span><span class="n">section</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

<span class="c1"># This is equivalent to vol.clone()</span>
<span class="n">vol</span><span class="o">.</span><span class="n">section</span><span class="p">()</span>
</pre></div>
</div>
<p>If a specific subclass of <cite>SplineObject</cite> is found that handles the
requested number of variable directions (parametric dimension), then
the return value is of that type. If not, it will be a generic <cite>SplineObject</cite>.</p>
<p>If the section has no variable directions (it is a point), then the
return value will be an array, unless the keyword argument
<cite>unwrap_points</cite> is true, in which case it will return a
zero-dimensional <cite>SplineObject</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>u</strong><strong>,</strong><strong>v</strong><strong>,</strong><strong>..</strong> (<em>int</em><em> or </em><em>None</em>) – Control point indices</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Section</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#splipy.SplineObject" title="splipy.SplineObject">SplineObject</a> or np.array</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.SplineObject.set_dimension">
<code class="descname">set_dimension</code><span class="sig-paren">(</span><em>new_dim</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/SplineObject.html#SplineObject.set_dimension"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.SplineObject.set_dimension" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the physical dimension of the object. If increased, the new
components are set to zero.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>new_dim</strong> (<em>int</em>) – New dimension.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">self</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.SplineObject.set_order">
<code class="descname">set_order</code><span class="sig-paren">(</span><em>*order</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/SplineObject.html#SplineObject.set_order"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.SplineObject.set_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the polynomial order of the object. If only one argument is
given, the order is set uniformly over all directions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>u</strong><strong>,</strong><strong>v</strong><strong>,</strong><strong>..</strong> (<em>int</em>) – The new order in a given direction.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><strong>ValueError</strong> – If the order is reduced in any direction.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">self</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="splipy.SplineObject.shape">
<code class="descname">shape</code><a class="headerlink" href="#splipy.SplineObject.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>The dimensions of the control point array.</p>
</dd></dl>

<dl class="method">
<dt id="splipy.SplineObject.split">
<code class="descname">split</code><span class="sig-paren">(</span><em>knots</em>, <em>direction=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/SplineObject.html#SplineObject.split"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.SplineObject.split" title="Permalink to this definition">¶</a></dt>
<dd><p>Split an object into two or more separate representations with C0
continuity between them.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>knots</strong> (<em>float</em><em> or </em><em>[</em><em>float</em><em>]</em>) – The splitting points</li>
<li><strong>direction</strong> (<em>int</em>) – Parametric direction</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The new objects</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">[<a class="reference internal" href="#splipy.SplineObject" title="splipy.SplineObject">SplineObject</a>]</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.SplineObject.start">
<code class="descname">start</code><span class="sig-paren">(</span><em>direction=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/SplineObject.html#SplineObject.start"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.SplineObject.start" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the start of the parametric domain.</p>
<p>If <cite>direction</cite> is given, returns the start of that direction, as a
float. If it is not given, returns the start of all directions, as a
tuple.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>direction</strong> (<em>int</em>) – Direction in which to get the start.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><strong>ValueError</strong> – For invalid direction</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.SplineObject.swap">
<code class="descname">swap</code><span class="sig-paren">(</span><em>dir1=0</em>, <em>dir2=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/SplineObject.html#SplineObject.swap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.SplineObject.swap" title="Permalink to this definition">¶</a></dt>
<dd><p>Swaps two parameter directions.</p>
<p>This function silently passes for curves.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>dir1</strong> (<em>direction</em>) – The first direction (default u)</li>
<li><strong>dir2</strong> (<em>direction</em>) – The second direction (default v)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">self</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.SplineObject.tangent">
<code class="descname">tangent</code><span class="sig-paren">(</span><em>*params</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/SplineObject.html#SplineObject.tangent"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.SplineObject.tangent" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the tangents of the object at the given parametric values.</p>
<p>If <cite>direction</cite> is given, only the derivatives in that direction are
evaluated. This is equivalent to calling
<a class="reference internal" href="#splipy.SplineObject.derivative" title="splipy.SplineObject.derivative"><code class="xref py py-func docutils literal notranslate"><span class="pre">splipy.SplineObject.derivative()</span></code></a> with
<cite>d=(0,…,0,1,0,…,0)</cite>, the unit vector corresponding to the given
direction.</p>
<p>If <cite>direction</cite> is not given, this function returns a tuple of all
tangential derivatives at the given points.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>u</strong><strong>,</strong><strong>v</strong><strong>,</strong><strong>..</strong> (<em>float</em><em> or </em><em>[</em><em>float</em><em>]</em>) – Parametric coordinates in which to evaluate</li>
<li><strong>direction</strong> (<em>int</em>) – The tangential direction</li>
<li><strong>above</strong> (<em>(</em><em>bool</em><em>)</em>) – Evaluation in the limit from above</li>
<li><strong>tensor</strong> (<em>bool</em>) – Whether to evaluate on a tensor product grid</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Tangents</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">tuple&lt;numpy.array&gt;</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.SplineObject.translate">
<code class="descname">translate</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/SplineObject.html#SplineObject.translate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.SplineObject.translate" title="Permalink to this definition">¶</a></dt>
<dd><p>Translate (i.e. move) the object by a given distance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>x</strong> (<em>array-like</em>) – The vector to translate by.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">self</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="curve">
<h2>Curve<a class="headerlink" href="#curve" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="splipy.Curve">
<em class="property">class </em><code class="descclassname">splipy.</code><code class="descname">Curve</code><a class="reference internal" href="_modules/splipy/Curve.html#Curve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.Curve" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">splipy.SplineObject.SplineObject</span></code></p>
<p>Represents a curve: an object with a one-dimensional parameter space.</p>
<dl class="method">
<dt id="splipy.Curve.evaluate">
<code class="descname">evaluate</code><span class="sig-paren">(</span><em>u</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/Curve.html#Curve.evaluate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.Curve.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the curve at the given parametric values.</p>
<p>This function returns an <em>n</em> × <em>dim</em> array, where <em>n</em> is the number of
evaluation points, and <em>dim</em> is the physical dimension of the curve.</p>
<p>If there is only one evaluation point, a vector of length <em>dim</em> is
returned instead.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>u</strong> (<em>float</em><em> or </em><em>[</em><em>float</em><em>]</em>) – Parametric coordinates in which to evaluate</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Geometry coordinates</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">numpy.array</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Curve.__getitem__">
<code class="descname">__getitem__</code><span class="sig-paren">(</span><em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Curve.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the control point at a given index.</p>
<p>Indexing is in column-major order. Examples of supported indexing
modes:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Flat indexing with an int</span>
<span class="n">obj</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>

<span class="c1"># Flat indexing from the end</span>
<span class="n">obj</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

<span class="c1"># Flat indexing with a slice</span>
<span class="n">obj</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>

<span class="c1"># Multi-indexing with ints, negative ints and slices</span>
<span class="n">obj</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,:]</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">numpy.array</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Curve.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>basis=None</em>, <em>controlpoints=None</em>, <em>rational=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/Curve.html#Curve.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.Curve.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a curve with the given basis and control points.</p>
<p>The default is to create a linear one-element mapping from (0,1) to the
unit interval.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>basis</strong> (<a class="reference internal" href="#splipy.BSplineBasis" title="splipy.BSplineBasis"><em>BSplineBasis</em></a>) – The underlying B-Spline basis</li>
<li><strong>controlpoints</strong> (<em>array-like</em>) – An <em>n</em> × <em>d</em> matrix of control points</li>
<li><strong>rational</strong> (<em>bool</em>) – Whether the curve is rational (in which case the
control points are interpreted as pre-multiplied with the weight,
which is the last coordinate)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Curve.__len__">
<code class="descname">__len__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Curve.__len__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of control points (basis functions) for the object.</p>
</dd></dl>

<dl class="method">
<dt id="splipy.Curve.__setitem__">
<code class="descname">__setitem__</code><span class="sig-paren">(</span><em>i</em>, <em>cp</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Curve.__setitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the control points at given indices.</p>
<p>This function supports the same indexing modes as
<code class="xref py py-func docutils literal notranslate"><span class="pre">SplineObject.__getitem__()</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>i</strong> (<em>int</em>) – Index or indices</li>
<li><strong>cp</strong> (<em>numpy.array</em>) – New control point(s)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Curve.append">
<code class="descname">append</code><span class="sig-paren">(</span><em>curve</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/Curve.html#Curve.append"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.Curve.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Extend the curve by merging another curve to the end of it.</p>
<p>The curves are glued together in a C0 fashion with enough repeated
knots. The function assumes that the end of this curve perfectly
matches the start of the input curve.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>curve</strong> (<a class="reference internal" href="#splipy.Curve" title="splipy.Curve"><em>Curve</em></a>) – Another curve</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><strong>RuntimeError</strong> – If either curve is periodic</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">self</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Curve.binormal">
<code class="descname">binormal</code><span class="sig-paren">(</span><em>t</em>, <em>above=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/Curve.html#Curve.binormal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.Curve.binormal" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the normalized binormal of the curve at the given parametric value(s).</p>
<p>This function returns an <em>n</em> × 3 array, where <em>n</em> is the number of
evaluation points.</p>
<p>The binormal is computed as the normalized cross product between the
velocity and acceleration of the curve.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>t</strong> (<em>float</em><em> or </em><em>[</em><em>float</em><em>]</em>) – Parametric coordinates in which to evaluate</li>
<li><strong>above</strong> (<em>bool</em>) – Evaluation in the limit from above</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Derivative array</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy.array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Curve.bounding_box">
<code class="descname">bounding_box</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Curve.bounding_box" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the bounding box of a spline object, computed from the
control-point values. Could be inaccurate for rational splines.</p>
<p>Returns the minima and maxima for each direction:
[(xmin, xmax), (ymin, ymax), …]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Bounding box</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">[(float)]</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Curve.center">
<code class="descname">center</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Curve.center" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the center of the domain</p>
<p>For curves this will return <span class="math notranslate">\((\tilde{x}, \tilde{y},...)\)</span>, where</p>
<div class="math notranslate">
\[\tilde{x} = \frac{1}{L} \int_{t_0}^{t_1} x(t) \; dt\]</div>
<p>and <span class="math notranslate">\(L=t_1-t_0\)</span> is the length of the parametric domain <span class="math notranslate">\([t_0,t_1]\)</span>.</p>
<p>For surfaces this will return <span class="math notranslate">\((\tilde{x}, \tilde{y},...)\)</span>, where</p>
<div class="math notranslate">
\[\tilde{x} = \frac{1}{A} \int_{v_0}^{v_1} \int_{u_0}^{u_1} x(u,v) \; du \; dv\]</div>
<p>and <span class="math notranslate">\(A=(u_1-u_0)(v_1-v_0)\)</span> is the area of the parametric domain <span class="math notranslate">\([u_0,u_1]\times[v_0,v_1]\)</span>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">For rational splines, this will integrate in projective
coordinates, then project the centerpoint. This is as opposed to
integrating the rational functions <span class="math notranslate">\(\frac{N_i(t)w_i}{\sum_j
N_j(t)w_j}\)</span>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="splipy.Curve.clone">
<code class="descname">clone</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Curve.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Clone the object.</p>
</dd></dl>

<dl class="method">
<dt id="splipy.Curve.continuity">
<code class="descname">continuity</code><span class="sig-paren">(</span><em>knot</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/Curve.html#Curve.continuity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.Curve.continuity" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the parametric continuity of the curve at a given point. Will
return p-1-m, where m is the knot multiplicity and inf between knots</p>
</dd></dl>

<dl class="method">
<dt id="splipy.Curve.corners">
<code class="descname">corners</code><span class="sig-paren">(</span><em>order='C'</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Curve.corners" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the corner control points.</p>
<p>The <cite>order</cite> parameter determines which order to use, either <code class="docutils literal notranslate"><span class="pre">'F'</span></code> or
<code class="docutils literal notranslate"><span class="pre">'C'</span></code>, for row-major or column-major ordering. E.g. for a volume, in
parametric coordinates,</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">'C'</span></code> gives (0,0,0), (1,0,0), (0,1,0), (1,1,0), (0,0,1), etc.</li>
<li><code class="docutils literal notranslate"><span class="pre">'F'</span></code> gives (0,0,0), (0,0,1), (0,1,0), (0,1,1), (1,0,0), etc.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>order</strong> (<em>str</em>) – The ordering to use</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Corners</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">np.array</td>
</tr>
</tbody>
</table>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">For rational splines, this will return the corners in
projective coordinates, including weights.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="splipy.Curve.curvature">
<code class="descname">curvature</code><span class="sig-paren">(</span><em>t</em>, <em>above=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/Curve.html#Curve.curvature"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.Curve.curvature" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the curvaure at specified point(s). The curvature is defined as</p>
<div class="math notranslate">
\[\frac{|\boldsymbol{v}\times \boldsymbol{a}|}{|\boldsymbol{v}|^3}\]</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>t</strong> (<em>float</em><em> or </em><em>[</em><em>float</em><em>]</em>) – Parametric coordinates in which to evaluate</li>
<li><strong>above</strong> (<em>bool</em>) – Evaluation in the limit from above</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Derivative array</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy.array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Curve.derivative">
<code class="descname">derivative</code><span class="sig-paren">(</span><em>t</em>, <em>d=1</em>, <em>above=True</em>, <em>tensor=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/Curve.html#Curve.derivative"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.Curve.derivative" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the derivative of the curve at the given parametric values.</p>
<p>This function returns an <em>n</em> × <em>dim</em> array, where <em>n</em> is the number of
evaluation points, and <em>dim</em> is the physical dimension of the curve.</p>
<p>If there is only one evaluation point, a vector of length <em>dim</em> is
returned instead.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>t</strong> (<em>float</em><em> or </em><em>[</em><em>float</em><em>]</em>) – Parametric coordinates in which to evaluate</li>
<li><strong>d</strong> (<em>int</em>) – Number of derivatives to compute</li>
<li><strong>above</strong> (<em>bool</em>) – Evaluation in the limit from above</li>
<li><strong>tensor</strong> (<em>bool</em>) – Not used in this method</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Derivative array</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy.array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Curve.end">
<code class="descname">end</code><span class="sig-paren">(</span><em>direction=None</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Curve.end" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the end of the parametric domain.</p>
<p>If <cite>direction</cite> is given, returns the end of that direction, as a float.
If it is not given, returns the end of all directions, as a tuple.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>direction</strong> (<em>int</em>) – Direction in which to get the end.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><strong>ValueError</strong> – For invalid direction</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Curve.error">
<code class="descname">error</code><span class="sig-paren">(</span><em>target</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/Curve.html#Curve.error"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.Curve.error" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the L2 (squared and per knot span) and max error between
this curve and a target curve</p>
<div class="math notranslate">
\[||\boldsymbol{x_h}(t)-\boldsymbol{x}(t)||_{L^2(t_1,t_2)}^2 = \int_{t_1}^{t_2}
|\boldsymbol{x_h}(t)-\boldsymbol{x}(t)|^2 dt, \quad \forall \;\text{knots}\;t_1 &lt; t_2\]</div>
<div class="math notranslate">
\[||\boldsymbol{x_h}(t)-\boldsymbol{x}(t)||_{L^\infty} = \max_t |\boldsymbol{x_h}(t)-\boldsymbol{x}(t)|\]</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>target</strong> (<em>function</em>) – callable function which takes as input a vector
of evaluation points t and gives as output a matrix x where
x[i,j] is component j evaluated at point t[i]</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">L2 error per knot-span and the maximum error</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">tuple(list(float), float)</td>
</tr>
</tbody>
</table>
<p>Examples:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="k">def</span> <span class="nf">arclength_circle</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)]</span> <span class="p">)</span><span class="o">.</span><span class="n">T</span>

<span class="n">crv</span> <span class="o">=</span> <span class="n">curve_factory</span><span class="o">.</span><span class="n">circle</span><span class="p">(</span><span class="n">r</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="p">(</span><span class="n">err2</span><span class="p">,</span> <span class="n">maxerr</span><span class="p">)</span> <span class="o">=</span> <span class="n">crv</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">arclength_circle</span><span class="p">)</span>
<span class="nb">print</span> <span class="s1">&#39;|| e ||_L2  = &#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">err2</span><span class="p">))</span>
<span class="nb">print</span> <span class="s1">&#39;|| e ||_max = &#39;</span><span class="p">,</span> <span class="n">maxerr</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="splipy.Curve.force_rational">
<code class="descname">force_rational</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Curve.force_rational" title="Permalink to this definition">¶</a></dt>
<dd><p>Force a rational representation of the object.</p>
<p>The weights of a non-rational object will be set to 1.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">self</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Curve.get_derivative_spline">
<code class="descname">get_derivative_spline</code><span class="sig-paren">(</span><em>direction=None</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Curve.get_derivative_spline" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the controlpoints associated with the derivative spline object</p>
<p>If <cite>direction</cite> is given, only the derivatives in that direction are
returned.</p>
<p>If <cite>direction</cite> is not given, this function returns a tuple of all
partial derivatives</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create a 4x4 element cubic spline surface</span>
<span class="n">surf</span> <span class="o">=</span> <span class="n">Surface</span><span class="p">()</span>
<span class="n">surf</span><span class="o">.</span><span class="n">raise_order</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">surf</span><span class="o">.</span><span class="n">refine</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="n">surf</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">,:]</span> <span class="o">+=</span> <span class="mf">0.1</span> <span class="c1"># make the surface non-trivial by moving controlpoints</span>

<span class="c1"># Create the derivative surface</span>
<span class="n">du</span> <span class="o">=</span> <span class="n">surf</span><span class="o">.</span><span class="n">get_derivative_spline</span><span class="p">(</span><span class="n">direction</span><span class="o">=</span><span class="s1">&#39;u&#39;</span><span class="p">)</span>

<span class="c1"># evaluation is identical</span>
<span class="nb">print</span><span class="p">(</span><span class="n">du</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">surf</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)))</span>

<span class="nb">print</span><span class="p">(</span><span class="n">surf</span><span class="o">.</span><span class="n">order</span><span class="p">())</span> <span class="c1"># prints (3,3)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">du</span><span class="o">.</span><span class="n">order</span><span class="p">())</span>   <span class="c1"># prints (2,3)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>direction</strong> (<em>int</em>) – The tangential direction</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Derivative spline</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#splipy.SplineObject" title="splipy.SplineObject">SplineObject</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Curve.get_kinks">
<code class="descname">get_kinks</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/Curve.html#Curve.get_kinks"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.Curve.get_kinks" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the parametric coordinates at all points which have C0-
continuity</p>
</dd></dl>

<dl class="method">
<dt id="splipy.Curve.insert_knot">
<code class="descname">insert_knot</code><span class="sig-paren">(</span><em>knot</em>, <em>direction=0</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Curve.insert_knot" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert a new knot into the spline.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>direction</strong> (<em>int</em>) – The direction to insert in</li>
<li><strong>knot</strong> (<em>float</em><em> or </em><em>[</em><em>float</em><em>]</em>) – The new knot(s) to insert</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>ValueError</strong> – For invalid direction</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">self</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Curve.knots">
<code class="descname">knots</code><span class="sig-paren">(</span><em>direction=None</em>, <em>with_multiplicities=False</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Curve.knots" title="Permalink to this definition">¶</a></dt>
<dd><p>Return knots vector</p>
<p>If <cite>direction</cite> is given, returns the knots in that direction, as a
list. If it is not given, returns the knots of all directions, as a
tuple.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>direction</strong> (<em>int</em>) – Direction in which to get the knots.</li>
<li><strong>with_multiplicities</strong> (<em>bool</em>) – If true, return knots with
multiplicities (i.e. repeated).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><strong>ValueError</strong> – For invalid direction</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Curve.length">
<code class="descname">length</code><span class="sig-paren">(</span><em>t0=None</em>, <em>t1=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/Curve.html#Curve.length"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.Curve.length" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the euclidian length of the curve in geometric space</p>
<div class="math notranslate">
\[\int_{t_0}^{t_1}\sqrt{x(t)^2 + y(t)^2 + z(t)^2} dt\]</div>
</dd></dl>

<dl class="method">
<dt id="splipy.Curve.lower_order">
<code class="descname">lower_order</code><span class="sig-paren">(</span><em>*lowers</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Curve.lower_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Lower the polynomial order of the object. If only one argument is
given, the order is lowered equally over all directions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>u</strong><strong>,</strong><strong>v</strong><strong>,</strong><strong>..</strong> (<em>int</em>) – Number of times to lower the order in a given
direction.</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Return SplineObject:</th></tr>
<tr class="field-even field"><td>&#160;</td><td class="field-body">Approximation of the current object on a lower
order basis</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Curve.lower_periodic">
<code class="descname">lower_periodic</code><span class="sig-paren">(</span><em>periodic</em>, <em>direction=0</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Curve.lower_periodic" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the periodicity of the spline object in the given direction,
keeping the geometry unchanged.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>periodic</strong> (<em>int</em>) – new periodicity, i.e. the basis is C^k over the start/end</li>
<li><strong>direction</strong> (<em>int</em>) – the parametric direction of the basis to modify</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">self</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Curve.make_periodic">
<code class="descname">make_periodic</code><span class="sig-paren">(</span><em>continuity=None</em>, <em>direction=0</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Curve.make_periodic" title="Permalink to this definition">¶</a></dt>
<dd><p>Make the spline object periodic in a given parametric direction.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>continuity</strong> (<em>int</em>) – The continuity along the boundary (default max).</li>
<li><strong>direction</strong> (<em>int</em>) – The direction to ensure continuity in.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="splipy.Curve.make_splines_compatible">
<em class="property">classmethod </em><code class="descname">make_splines_compatible</code><span class="sig-paren">(</span><em>spline1</em>, <em>spline2</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Curve.make_splines_compatible" title="Permalink to this definition">¶</a></dt>
<dd><p>Ensure that two splines are compatible.</p>
<p>This will manipulate one or both to ensure that they are both rational
or nonrational, and that they lie in the same physical space.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>spline1</strong> (<a class="reference internal" href="#splipy.SplineObject" title="splipy.SplineObject"><em>SplineObject</em></a>) – The first spline</li>
<li><strong>spline2</strong> (<a class="reference internal" href="#splipy.SplineObject" title="splipy.SplineObject"><em>SplineObject</em></a>) – The second spline</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="splipy.Curve.make_splines_identical">
<em class="property">classmethod </em><code class="descname">make_splines_identical</code><span class="sig-paren">(</span><em>spline1</em>, <em>spline2</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Curve.make_splines_identical" title="Permalink to this definition">¶</a></dt>
<dd><p>Ensure that two splines have identical discretization.</p>
<p>This will first make them compatible (see
<code class="xref py py-func docutils literal notranslate"><span class="pre">splipy.SplineObject.make_curves_compatible()</span></code>), reparametrize them, and
possibly raise the order and insert knots as required.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>spline1</strong> (<a class="reference internal" href="#splipy.SplineObject" title="splipy.SplineObject"><em>SplineObject</em></a>) – The first spline</li>
<li><strong>spline2</strong> (<a class="reference internal" href="#splipy.SplineObject" title="splipy.SplineObject"><em>SplineObject</em></a>) – The second spline</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Curve.mirror">
<code class="descname">mirror</code><span class="sig-paren">(</span><em>normal</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Curve.mirror" title="Permalink to this definition">¶</a></dt>
<dd><p>Mirror the object around a plane through the origin.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>normal</strong> (<em>array-like</em>) – The plane normal to mirror about.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><strong>RuntimeError</strong> – If the physical dimension is not 2 or 3</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">self</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Curve.normal">
<code class="descname">normal</code><span class="sig-paren">(</span><em>t</em>, <em>above=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/Curve.html#Curve.normal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.Curve.normal" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the normal of the curve at the given parametric value(s).</p>
<p>This function returns an <em>n</em> × 3 array, where <em>n</em> is the number of
evaluation points.</p>
<p>The normal is computed as the cross product between the binormal and
the tangent of the curve.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>t</strong> (<em>float</em><em> or </em><em>[</em><em>float</em><em>]</em>) – Parametric coordinates in which to evaluate</li>
<li><strong>above</strong> (<em>bool</em>) – Evaluation in the limit from above</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Derivative array</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy.array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Curve.order">
<code class="descname">order</code><span class="sig-paren">(</span><em>direction=None</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Curve.order" title="Permalink to this definition">¶</a></dt>
<dd><p>Return polynomial order (degree + 1).</p>
<p>If <cite>direction</cite> is given, returns the order of that direction, as an
int. If it is not given, returns the order of all directions, as a
tuple.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>direction</strong> (<em>int</em>) – Direction in which to get the order.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><strong>ValueError</strong> – For invalid direction</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="splipy.Curve.pardim">
<code class="descname">pardim</code><a class="headerlink" href="#splipy.Curve.pardim" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of parametric dimensions: 1 for curves, 2 for surfaces, 3
for volumes, etc.</p>
</dd></dl>

<dl class="method">
<dt id="splipy.Curve.periodic">
<code class="descname">periodic</code><span class="sig-paren">(</span><em>direction=0</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Curve.periodic" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if the spline object is periodic in the given parametric direction</p>
</dd></dl>

<dl class="method">
<dt id="splipy.Curve.project">
<code class="descname">project</code><span class="sig-paren">(</span><em>plane</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Curve.project" title="Permalink to this definition">¶</a></dt>
<dd><p>Projects the geometry onto a plane or axis.</p>
<ul class="simple">
<li><cite>project(‘xy’)</cite> will project the object onto the <em>xy</em> plane, setting
all <em>z</em> components to zero.</li>
<li><cite>project(‘y’)</cite> will project the object onto the <em>y</em> axis, setting all
<em>x</em> and <em>z</em> components to zero.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>plane</strong> (<em>string</em>) – Any combination of ‘x’, ‘y’ and ‘z’</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">self</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Curve.raise_order">
<code class="descname">raise_order</code><span class="sig-paren">(</span><em>amount</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/Curve.html#Curve.raise_order"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.Curve.raise_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Raise the polynomial order of the curve.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>amount</strong> (<em>int</em>) – Number of times to raise the order</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">self</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Curve.rebuild">
<code class="descname">rebuild</code><span class="sig-paren">(</span><em>p</em>, <em>n</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/Curve.html#Curve.rebuild"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.Curve.rebuild" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates an approximation to this curve by resampling it using a
uniform knot vector of order <em>p</em> with <em>n</em> control points.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>p</strong> (<em>int</em>) – Polynomial discretization order</li>
<li><strong>n</strong> (<em>int</em>) – Number of control points</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A new approximate curve</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#splipy.Curve" title="splipy.Curve">Curve</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Curve.refine">
<code class="descname">refine</code><span class="sig-paren">(</span><em>*ns</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Curve.refine" title="Permalink to this definition">¶</a></dt>
<dd><p>Enrich the spline space by inserting knots into each existing knot
span.</p>
<p>This method supports three different usage patterns:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Refine each direction by a factor n</span>
<span class="n">obj</span><span class="o">.</span><span class="n">refine</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

<span class="c1"># Refine a single direction by a factor n</span>
<span class="n">obj</span><span class="o">.</span><span class="n">refine</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;v&#39;</span><span class="p">)</span>

<span class="c1"># Refine all directions by given factors</span>
<span class="n">obj</span><span class="o">.</span><span class="n">refine</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">nv</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>nu</strong><strong>,</strong><strong>nv</strong><strong>,</strong><strong>..</strong> (<em>int</em>) – Number of new knots to insert into each span</li>
<li><strong>direction</strong> (<em>int</em>) – Direction to refine in</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">self</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Curve.reparam">
<code class="descname">reparam</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Curve.reparam" title="Permalink to this definition">¶</a></dt>
<dd><p>Redefine the parametric domain. This function accepts two calling
conventions:</p>
<p><cite>reparametrize(u, v, …)</cite> reparametrizes each direction to the domains
given by the tuples <em>u</em>, <em>v</em>, etc. It is equivalent to calling
<cite>reparametrize(u[0], u[1])</cite> on each basis. The default domain for
directions not given is (0,1). In particular, if no arguments are
given, the new parametric domain will be the unit (hyper)cube.</p>
<p><cite>reparametrize(u, direction=d)</cite> reparametrizes just the direction given
by <em>d</em> and leaves the others untouched.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>u</strong><strong>, </strong><strong>v</strong><strong>, </strong><strong>..</strong> (<em>tuple</em>) – New parametric domains, default to (0,1)</li>
<li><strong>direction</strong> (<em>int</em>) – The direction to reparametrize</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">self</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Curve.reverse">
<code class="descname">reverse</code><span class="sig-paren">(</span><em>direction=0</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Curve.reverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Swap the direction of a parameter by making it go in the reverse
direction. The parametric domain remains unchanged.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>direction</strong> (<em>int</em>) – The direction to flip.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">self</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Curve.rotate">
<code class="descname">rotate</code><span class="sig-paren">(</span><em>theta</em>, <em>normal=(0</em>, <em>0</em>, <em>1)</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Curve.rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate the object around an axis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>theta</strong> (<em>float</em>) – Angle to rotate about, measured in radians</li>
<li><strong>normal</strong> (<em>array-like</em>) – The normal axis (if 3D) to rotate about</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>RuntimeError</strong> – If the physical dimension is not 2 or 3</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">self</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Curve.scale">
<code class="descname">scale</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Curve.scale" title="Permalink to this definition">¶</a></dt>
<dd><p>Scale, or magnify the object by a given amount.</p>
<p>In case of one input argument, the scaling is uniform.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>args</strong> (<em>array-like</em><em> or </em><em>float</em>) – Scaling factors, possibly different in each direction.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">self</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Curve.section">
<code class="descname">section</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Curve.section" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a section from the object. A section can be any sub-object of
parametric dimension not exceeding that of the object. E.g. for a
volume, sections include vertices, edges, faces, etc.</p>
<p>The arguments are control point indices for each direction. <cite>None</cite>
means that direction should be variable in the returned object.</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Get the face with u=max</span>
<span class="n">vol</span><span class="o">.</span><span class="n">section</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

<span class="c1"># Keyword arguments are supported for u, v and w</span>
<span class="c1"># This is the same as the above</span>
<span class="n">vol</span><span class="o">.</span><span class="n">section</span><span class="p">(</span><span class="n">u</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Get the edge with u=min, v=max</span>
<span class="n">vol</span><span class="o">.</span><span class="n">section</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

<span class="c1"># This is equivalent to vol.clone()</span>
<span class="n">vol</span><span class="o">.</span><span class="n">section</span><span class="p">()</span>
</pre></div>
</div>
<p>If a specific subclass of <cite>SplineObject</cite> is found that handles the
requested number of variable directions (parametric dimension), then
the return value is of that type. If not, it will be a generic <cite>SplineObject</cite>.</p>
<p>If the section has no variable directions (it is a point), then the
return value will be an array, unless the keyword argument
<cite>unwrap_points</cite> is true, in which case it will return a
zero-dimensional <cite>SplineObject</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>u</strong><strong>,</strong><strong>v</strong><strong>,</strong><strong>..</strong> (<em>int</em><em> or </em><em>None</em>) – Control point indices</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Section</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#splipy.SplineObject" title="splipy.SplineObject">SplineObject</a> or np.array</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Curve.set_dimension">
<code class="descname">set_dimension</code><span class="sig-paren">(</span><em>new_dim</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Curve.set_dimension" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the physical dimension of the object. If increased, the new
components are set to zero.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>new_dim</strong> (<em>int</em>) – New dimension.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">self</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Curve.set_order">
<code class="descname">set_order</code><span class="sig-paren">(</span><em>*order</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Curve.set_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the polynomial order of the object. If only one argument is
given, the order is set uniformly over all directions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>u</strong><strong>,</strong><strong>v</strong><strong>,</strong><strong>..</strong> (<em>int</em>) – The new order in a given direction.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><strong>ValueError</strong> – If the order is reduced in any direction.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">self</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="splipy.Curve.shape">
<code class="descname">shape</code><a class="headerlink" href="#splipy.Curve.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>The dimensions of the control point array.</p>
</dd></dl>

<dl class="method">
<dt id="splipy.Curve.split">
<code class="descname">split</code><span class="sig-paren">(</span><em>knots</em>, <em>direction=0</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Curve.split" title="Permalink to this definition">¶</a></dt>
<dd><p>Split an object into two or more separate representations with C0
continuity between them.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>knots</strong> (<em>float</em><em> or </em><em>[</em><em>float</em><em>]</em>) – The splitting points</li>
<li><strong>direction</strong> (<em>int</em>) – Parametric direction</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The new objects</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">[<a class="reference internal" href="#splipy.SplineObject" title="splipy.SplineObject">SplineObject</a>]</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Curve.start">
<code class="descname">start</code><span class="sig-paren">(</span><em>direction=None</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Curve.start" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the start of the parametric domain.</p>
<p>If <cite>direction</cite> is given, returns the start of that direction, as a
float. If it is not given, returns the start of all directions, as a
tuple.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>direction</strong> (<em>int</em>) – Direction in which to get the start.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><strong>ValueError</strong> – For invalid direction</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Curve.swap">
<code class="descname">swap</code><span class="sig-paren">(</span><em>dir1=0</em>, <em>dir2=1</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Curve.swap" title="Permalink to this definition">¶</a></dt>
<dd><p>Swaps two parameter directions.</p>
<p>This function silently passes for curves.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>dir1</strong> (<em>direction</em>) – The first direction (default u)</li>
<li><strong>dir2</strong> (<em>direction</em>) – The second direction (default v)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">self</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Curve.tangent">
<code class="descname">tangent</code><span class="sig-paren">(</span><em>*params</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Curve.tangent" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the tangents of the object at the given parametric values.</p>
<p>If <cite>direction</cite> is given, only the derivatives in that direction are
evaluated. This is equivalent to calling
<a class="reference internal" href="#splipy.SplineObject.derivative" title="splipy.SplineObject.derivative"><code class="xref py py-func docutils literal notranslate"><span class="pre">splipy.SplineObject.derivative()</span></code></a> with
<cite>d=(0,…,0,1,0,…,0)</cite>, the unit vector corresponding to the given
direction.</p>
<p>If <cite>direction</cite> is not given, this function returns a tuple of all
tangential derivatives at the given points.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>u</strong><strong>,</strong><strong>v</strong><strong>,</strong><strong>..</strong> (<em>float</em><em> or </em><em>[</em><em>float</em><em>]</em>) – Parametric coordinates in which to evaluate</li>
<li><strong>direction</strong> (<em>int</em>) – The tangential direction</li>
<li><strong>above</strong> (<em>(</em><em>bool</em><em>)</em>) – Evaluation in the limit from above</li>
<li><strong>tensor</strong> (<em>bool</em>) – Whether to evaluate on a tensor product grid</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Tangents</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">tuple&lt;numpy.array&gt;</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Curve.torsion">
<code class="descname">torsion</code><span class="sig-paren">(</span><em>t</em>, <em>above=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/Curve.html#Curve.torsion"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.Curve.torsion" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the torsion for a 3D curve at specified point(s). The torsion is defined as</p>
<div class="math notranslate">
\[\frac{(\boldsymbol{v}\times \boldsymbol{a})\cdot (d\boldsymbol{a}/dt)}{|\boldsymbol{v}\times \boldsymbol{a}|^2}\]</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>t</strong> (<em>float</em><em> or </em><em>[</em><em>float</em><em>]</em>) – Parametric coordinates in which to evaluate</li>
<li><strong>above</strong> (<em>bool</em>) – Evaluation in the limit from above</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Derivative array</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy.array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Curve.translate">
<code class="descname">translate</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Curve.translate" title="Permalink to this definition">¶</a></dt>
<dd><p>Translate (i.e. move) the object by a given distance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>x</strong> (<em>array-like</em>) – The vector to translate by.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">self</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="surface">
<h2>Surface<a class="headerlink" href="#surface" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="splipy.Surface">
<em class="property">class </em><code class="descclassname">splipy.</code><code class="descname">Surface</code><a class="reference internal" href="_modules/splipy/Surface.html#Surface"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.Surface" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">splipy.SplineObject.SplineObject</span></code></p>
<p>Represents a surface: an object with a two-dimensional parameter space.</p>
<dl class="method">
<dt id="splipy.Surface.evaluate">
<code class="descname">evaluate</code><span class="sig-paren">(</span><em>u</em>, <em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Surface.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the surface at the given parametric values.</p>
<p>This function returns an <em>n1</em> × <em>n2</em> × <em>dim</em> array, where <em>ni</em> is the
number of evaluation points in each direction, and <em>dim</em> is the dimension
of the surface.</p>
<p>If there is only one evaluation point, a vector of length <em>dim</em> is
returned instead.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>u</strong> (<em>float</em><em> or </em><em>[</em><em>float</em><em>]</em>) – Parametric coordinates in the first direction</li>
<li><strong>u</strong> – Parametric coordinates in the second direction</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Geometry coordinates</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy.array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Surface.evalute_derivative">
<code class="descname">evalute_derivative</code><span class="sig-paren">(</span><em>u</em>, <em>v</em><span class="optional">[</span>, <em>d=(1</em>, <em>1)</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Surface.evalute_derivative" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the derivative of the surface at the given parametric values.</p>
<p>This function returns an <em>n1</em> × <em>n2</em> × <em>dim</em> array, where <em>ni</em> is the
number of evaluation points in direction <em>i</em>, and <em>dim</em> is the dimension
of the surface.</p>
<p>If there is only one evaluation point, a vector of length <em>dim</em> is
returned instead.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>u</strong> (<em>float</em><em> or </em><em>[</em><em>float</em><em>]</em>) – Parametric coordinates in the first direction</li>
<li><strong>u</strong> – Parametric coordinates in the second direction</li>
<li><strong>d</strong> (<em>(</em><em>int</em><em>)</em>) – Order of derivative to compute</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Derivatives</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy.array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Surface.__getitem__">
<code class="descname">__getitem__</code><span class="sig-paren">(</span><em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Surface.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the control point at a given index.</p>
<p>Indexing is in column-major order. Examples of supported indexing
modes:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Flat indexing with an int</span>
<span class="n">obj</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>

<span class="c1"># Flat indexing from the end</span>
<span class="n">obj</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

<span class="c1"># Flat indexing with a slice</span>
<span class="n">obj</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>

<span class="c1"># Multi-indexing with ints, negative ints and slices</span>
<span class="n">obj</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,:]</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">numpy.array</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Surface.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>basis1=None</em>, <em>basis2=None</em>, <em>controlpoints=None</em>, <em>rational=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/Surface.html#Surface.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.Surface.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a surface with the given basis and control points.</p>
<p>The default is to create a linear one-element mapping from and to the
unit square.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>basis1</strong> (<a class="reference internal" href="#splipy.BSplineBasis" title="splipy.BSplineBasis"><em>BSplineBasis</em></a>) – The basis of the first parameter direction</li>
<li><strong>basis2</strong> (<a class="reference internal" href="#splipy.BSplineBasis" title="splipy.BSplineBasis"><em>BSplineBasis</em></a>) – The basis of the second parameter direction</li>
<li><strong>controlpoints</strong> (<em>array-like</em>) – An <em>n1</em> × <em>n2</em> × <em>d</em> matrix of control points</li>
<li><strong>rational</strong> (<em>bool</em>) – Whether the surface is rational (in which case the
control points are interpreted as pre-multiplied with the weight,
which is the last coordinate)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Surface.__len__">
<code class="descname">__len__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Surface.__len__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of control points (basis functions) for the object.</p>
</dd></dl>

<dl class="method">
<dt id="splipy.Surface.__setitem__">
<code class="descname">__setitem__</code><span class="sig-paren">(</span><em>i</em>, <em>cp</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Surface.__setitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the control points at given indices.</p>
<p>This function supports the same indexing modes as
<code class="xref py py-func docutils literal notranslate"><span class="pre">SplineObject.__getitem__()</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>i</strong> (<em>int</em>) – Index or indices</li>
<li><strong>cp</strong> (<em>numpy.array</em>) – New control point(s)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Surface.area">
<code class="descname">area</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/Surface.html#Surface.area"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.Surface.area" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the area of the surface in geometric space</p>
</dd></dl>

<dl class="method">
<dt id="splipy.Surface.bounding_box">
<code class="descname">bounding_box</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Surface.bounding_box" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the bounding box of a spline object, computed from the
control-point values. Could be inaccurate for rational splines.</p>
<p>Returns the minima and maxima for each direction:
[(xmin, xmax), (ymin, ymax), …]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Bounding box</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">[(float)]</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Surface.center">
<code class="descname">center</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Surface.center" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the center of the domain</p>
<p>For curves this will return <span class="math notranslate">\((\tilde{x}, \tilde{y},...)\)</span>, where</p>
<div class="math notranslate">
\[\tilde{x} = \frac{1}{L} \int_{t_0}^{t_1} x(t) \; dt\]</div>
<p>and <span class="math notranslate">\(L=t_1-t_0\)</span> is the length of the parametric domain <span class="math notranslate">\([t_0,t_1]\)</span>.</p>
<p>For surfaces this will return <span class="math notranslate">\((\tilde{x}, \tilde{y},...)\)</span>, where</p>
<div class="math notranslate">
\[\tilde{x} = \frac{1}{A} \int_{v_0}^{v_1} \int_{u_0}^{u_1} x(u,v) \; du \; dv\]</div>
<p>and <span class="math notranslate">\(A=(u_1-u_0)(v_1-v_0)\)</span> is the area of the parametric domain <span class="math notranslate">\([u_0,u_1]\times[v_0,v_1]\)</span>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">For rational splines, this will integrate in projective
coordinates, then project the centerpoint. This is as opposed to
integrating the rational functions <span class="math notranslate">\(\frac{N_i(t)w_i}{\sum_j
N_j(t)w_j}\)</span>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="splipy.Surface.clone">
<code class="descname">clone</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Surface.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Clone the object.</p>
</dd></dl>

<dl class="method">
<dt id="splipy.Surface.const_par_curve">
<code class="descname">const_par_curve</code><span class="sig-paren">(</span><em>knot</em>, <em>direction</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/Surface.html#Surface.const_par_curve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.Surface.const_par_curve" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a Curve representation of the parametric line of some constant
knot value.
:param float knot: The constant knot value to sample the surface
:param int direction: The parametric direction for the constant value
:return: curve on this surface
:rtype: Curve</p>
</dd></dl>

<dl class="method">
<dt id="splipy.Surface.corners">
<code class="descname">corners</code><span class="sig-paren">(</span><em>order='C'</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Surface.corners" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the corner control points.</p>
<p>The <cite>order</cite> parameter determines which order to use, either <code class="docutils literal notranslate"><span class="pre">'F'</span></code> or
<code class="docutils literal notranslate"><span class="pre">'C'</span></code>, for row-major or column-major ordering. E.g. for a volume, in
parametric coordinates,</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">'C'</span></code> gives (0,0,0), (1,0,0), (0,1,0), (1,1,0), (0,0,1), etc.</li>
<li><code class="docutils literal notranslate"><span class="pre">'F'</span></code> gives (0,0,0), (0,0,1), (0,1,0), (0,1,1), (1,0,0), etc.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>order</strong> (<em>str</em>) – The ordering to use</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Corners</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">np.array</td>
</tr>
</tbody>
</table>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">For rational splines, this will return the corners in
projective coordinates, including weights.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="splipy.Surface.derivative">
<code class="descname">derivative</code><span class="sig-paren">(</span><em>*params</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Surface.derivative" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the derivative of the object at the given parametric values.</p>
<p>If <em>tensor</em> is true, evaluation will take place on a tensor product
grid, i.e. it will return an <em>n1</em> × <em>n2</em> × … × <em>dim</em> array, where
<em>ni</em> is the number of evaluation points in direction <em>i</em>, and <em>dim</em> is
the physical dimension of the object.</p>
<p>If <em>tensor</em> is false, there must be an equal number <em>n</em> of evaluation
points in all directions, and the return value will be an <em>n</em> × <em>dim</em>
array.</p>
<p>If there is only one evaluation point, a vector of length <em>dim</em> is
returned instead.</p>
<p>Examples:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Tangent of curve at single point</span>
<span class="n">curve</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>

<span class="c1"># Double derivative of curve at single point:</span>
<span class="n">curve</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># Third derivative of curve at several points:</span>
<span class="n">curve</span><span class="o">.</span><span class="n">derivative</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> <span class="n">d</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

<span class="c1"># Tangents of surface:</span>
<span class="n">surface</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
<span class="n">surface</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>

<span class="c1"># Cross-derivative of surface:</span>
<span class="n">surface</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>u</strong><strong>,</strong><strong>v</strong><strong>,</strong><strong>..</strong> (<em>float</em><em> or </em><em>[</em><em>float</em><em>]</em>) – Parametric coordinates in which to evaluate</li>
<li><strong>d</strong> (<em>(</em><em>int</em><em>)</em>) – Order of derivative to compute</li>
<li><strong>above</strong> (<em>(</em><em>bool</em><em>)</em>) – Evaluation in the limit from above</li>
<li><strong>tensor</strong> (<em>bool</em>) – Whether to evaluate on a tensor product grid</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Derivatives</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy.array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Surface.edges">
<code class="descname">edges</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/Surface.html#Surface.edges"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.Surface.edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the four edge curves in (parametric) order: umin, umax, vmin, vmax</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Edge curves</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">(<a class="reference internal" href="#splipy.Curve" title="splipy.Curve">Curve</a>)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Surface.end">
<code class="descname">end</code><span class="sig-paren">(</span><em>direction=None</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Surface.end" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the end of the parametric domain.</p>
<p>If <cite>direction</cite> is given, returns the end of that direction, as a float.
If it is not given, returns the end of all directions, as a tuple.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>direction</strong> (<em>int</em>) – Direction in which to get the end.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><strong>ValueError</strong> – For invalid direction</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Surface.force_rational">
<code class="descname">force_rational</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Surface.force_rational" title="Permalink to this definition">¶</a></dt>
<dd><p>Force a rational representation of the object.</p>
<p>The weights of a non-rational object will be set to 1.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">self</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Surface.get_derivative_spline">
<code class="descname">get_derivative_spline</code><span class="sig-paren">(</span><em>direction=None</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Surface.get_derivative_spline" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the controlpoints associated with the derivative spline object</p>
<p>If <cite>direction</cite> is given, only the derivatives in that direction are
returned.</p>
<p>If <cite>direction</cite> is not given, this function returns a tuple of all
partial derivatives</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create a 4x4 element cubic spline surface</span>
<span class="n">surf</span> <span class="o">=</span> <span class="n">Surface</span><span class="p">()</span>
<span class="n">surf</span><span class="o">.</span><span class="n">raise_order</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">surf</span><span class="o">.</span><span class="n">refine</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="n">surf</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">,:]</span> <span class="o">+=</span> <span class="mf">0.1</span> <span class="c1"># make the surface non-trivial by moving controlpoints</span>

<span class="c1"># Create the derivative surface</span>
<span class="n">du</span> <span class="o">=</span> <span class="n">surf</span><span class="o">.</span><span class="n">get_derivative_spline</span><span class="p">(</span><span class="n">direction</span><span class="o">=</span><span class="s1">&#39;u&#39;</span><span class="p">)</span>

<span class="c1"># evaluation is identical</span>
<span class="nb">print</span><span class="p">(</span><span class="n">du</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">surf</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)))</span>

<span class="nb">print</span><span class="p">(</span><span class="n">surf</span><span class="o">.</span><span class="n">order</span><span class="p">())</span> <span class="c1"># prints (3,3)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">du</span><span class="o">.</span><span class="n">order</span><span class="p">())</span>   <span class="c1"># prints (2,3)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>direction</strong> (<em>int</em>) – The tangential direction</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Derivative spline</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#splipy.SplineObject" title="splipy.SplineObject">SplineObject</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Surface.get_derivative_surface">
<code class="descname">get_derivative_surface</code><span class="sig-paren">(</span><em>direction=None</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Surface.get_derivative_surface" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the controlpoints associated with the derivative spline object</p>
<p>If <cite>direction</cite> is given, only the derivatives in that direction are
returned.</p>
<p>If <cite>direction</cite> is not given, this function returns a tuple of all
partial derivatives</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create a 4x4 element cubic spline surface</span>
<span class="n">surf</span> <span class="o">=</span> <span class="n">Surface</span><span class="p">()</span>
<span class="n">surf</span><span class="o">.</span><span class="n">raise_order</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">surf</span><span class="o">.</span><span class="n">refine</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="n">surf</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">,:]</span> <span class="o">+=</span> <span class="mf">0.1</span> <span class="c1"># make the surface non-trivial by moving controlpoints</span>

<span class="c1"># Create the derivative surface</span>
<span class="n">du</span> <span class="o">=</span> <span class="n">surf</span><span class="o">.</span><span class="n">get_derivative_spline</span><span class="p">(</span><span class="n">direction</span><span class="o">=</span><span class="s1">&#39;u&#39;</span><span class="p">)</span>

<span class="c1"># evaluation is identical</span>
<span class="nb">print</span><span class="p">(</span><span class="n">du</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">surf</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)))</span>

<span class="nb">print</span><span class="p">(</span><span class="n">surf</span><span class="o">.</span><span class="n">order</span><span class="p">())</span> <span class="c1"># prints (3,3)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">du</span><span class="o">.</span><span class="n">order</span><span class="p">())</span>   <span class="c1"># prints (2,3)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>direction</strong> (<em>int</em>) – The tangential direction</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Derivative spline</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#splipy.SplineObject" title="splipy.SplineObject">SplineObject</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Surface.insert_knot">
<code class="descname">insert_knot</code><span class="sig-paren">(</span><em>knot</em>, <em>direction=0</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Surface.insert_knot" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert a new knot into the spline.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>direction</strong> (<em>int</em>) – The direction to insert in</li>
<li><strong>knot</strong> (<em>float</em><em> or </em><em>[</em><em>float</em><em>]</em>) – The new knot(s) to insert</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>ValueError</strong> – For invalid direction</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">self</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Surface.knots">
<code class="descname">knots</code><span class="sig-paren">(</span><em>direction=None</em>, <em>with_multiplicities=False</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Surface.knots" title="Permalink to this definition">¶</a></dt>
<dd><p>Return knots vector</p>
<p>If <cite>direction</cite> is given, returns the knots in that direction, as a
list. If it is not given, returns the knots of all directions, as a
tuple.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>direction</strong> (<em>int</em>) – Direction in which to get the knots.</li>
<li><strong>with_multiplicities</strong> (<em>bool</em>) – If true, return knots with
multiplicities (i.e. repeated).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><strong>ValueError</strong> – For invalid direction</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Surface.lower_order">
<code class="descname">lower_order</code><span class="sig-paren">(</span><em>*lowers</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Surface.lower_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Lower the polynomial order of the object. If only one argument is
given, the order is lowered equally over all directions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>u</strong><strong>,</strong><strong>v</strong><strong>,</strong><strong>..</strong> (<em>int</em>) – Number of times to lower the order in a given
direction.</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Return SplineObject:</th></tr>
<tr class="field-even field"><td>&#160;</td><td class="field-body">Approximation of the current object on a lower
order basis</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Surface.lower_periodic">
<code class="descname">lower_periodic</code><span class="sig-paren">(</span><em>periodic</em>, <em>direction=0</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Surface.lower_periodic" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the periodicity of the spline object in the given direction,
keeping the geometry unchanged.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>periodic</strong> (<em>int</em>) – new periodicity, i.e. the basis is C^k over the start/end</li>
<li><strong>direction</strong> (<em>int</em>) – the parametric direction of the basis to modify</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">self</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Surface.make_periodic">
<code class="descname">make_periodic</code><span class="sig-paren">(</span><em>continuity=None</em>, <em>direction=0</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Surface.make_periodic" title="Permalink to this definition">¶</a></dt>
<dd><p>Make the spline object periodic in a given parametric direction.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>continuity</strong> (<em>int</em>) – The continuity along the boundary (default max).</li>
<li><strong>direction</strong> (<em>int</em>) – The direction to ensure continuity in.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="splipy.Surface.make_splines_compatible">
<em class="property">classmethod </em><code class="descname">make_splines_compatible</code><span class="sig-paren">(</span><em>spline1</em>, <em>spline2</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Surface.make_splines_compatible" title="Permalink to this definition">¶</a></dt>
<dd><p>Ensure that two splines are compatible.</p>
<p>This will manipulate one or both to ensure that they are both rational
or nonrational, and that they lie in the same physical space.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>spline1</strong> (<a class="reference internal" href="#splipy.SplineObject" title="splipy.SplineObject"><em>SplineObject</em></a>) – The first spline</li>
<li><strong>spline2</strong> (<a class="reference internal" href="#splipy.SplineObject" title="splipy.SplineObject"><em>SplineObject</em></a>) – The second spline</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="splipy.Surface.make_splines_identical">
<em class="property">classmethod </em><code class="descname">make_splines_identical</code><span class="sig-paren">(</span><em>spline1</em>, <em>spline2</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Surface.make_splines_identical" title="Permalink to this definition">¶</a></dt>
<dd><p>Ensure that two splines have identical discretization.</p>
<p>This will first make them compatible (see
<code class="xref py py-func docutils literal notranslate"><span class="pre">splipy.SplineObject.make_curves_compatible()</span></code>), reparametrize them, and
possibly raise the order and insert knots as required.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>spline1</strong> (<a class="reference internal" href="#splipy.SplineObject" title="splipy.SplineObject"><em>SplineObject</em></a>) – The first spline</li>
<li><strong>spline2</strong> (<a class="reference internal" href="#splipy.SplineObject" title="splipy.SplineObject"><em>SplineObject</em></a>) – The second spline</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Surface.mirror">
<code class="descname">mirror</code><span class="sig-paren">(</span><em>normal</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Surface.mirror" title="Permalink to this definition">¶</a></dt>
<dd><p>Mirror the object around a plane through the origin.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>normal</strong> (<em>array-like</em>) – The plane normal to mirror about.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><strong>RuntimeError</strong> – If the physical dimension is not 2 or 3</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">self</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Surface.normal">
<code class="descname">normal</code><span class="sig-paren">(</span><em>u</em>, <em>v</em>, <em>above=(True</em>, <em>True)</em>, <em>tensor=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/Surface.html#Surface.normal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.Surface.normal" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the normal of the surface at given parametric values.</p>
<p>This is equal to the cross-product between tangents. The return value
is normalized.</p>
<p>If <em>tensor</em> is true, evaluation will take place on a tensor product
grid, i.e. it will return an <em>n1</em> × <em>n2</em> × … × <em>dim</em> array, where
<em>ni</em> is the number of evaluation points in direction <em>i</em>, and <em>dim</em> is
the physical dimension of the object.</p>
<p>If <em>tensor</em> is false, there must be an equal number <em>n</em> of evaluation
points in all directions, and the return value will be an <em>n</em> × <em>dim</em>
array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>u</strong> (<em>float</em><em> or </em><em>[</em><em>float</em><em>]</em>) – Parametric coordinate(s) in the first direction</li>
<li><strong>v</strong> (<em>float</em><em> or </em><em>[</em><em>float</em><em>]</em>) – Parametric coordinate(s) in the second direction</li>
<li><strong>above</strong> (<em>(</em><em>bool</em><em>)</em>) – Evaluation in the limit from above</li>
<li><strong>tensor</strong> (<em>bool</em>) – Whether to evaluate on a tensor product grid</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Normal array <em>X[i,j,k]</em> of component <em>xk</em> evaluated at <em>(u[i], v[j])</em></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">numpy.array</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><strong>RuntimeError</strong> – If the physical dimension is not 2 or 3</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Surface.order">
<code class="descname">order</code><span class="sig-paren">(</span><em>direction=None</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Surface.order" title="Permalink to this definition">¶</a></dt>
<dd><p>Return polynomial order (degree + 1).</p>
<p>If <cite>direction</cite> is given, returns the order of that direction, as an
int. If it is not given, returns the order of all directions, as a
tuple.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>direction</strong> (<em>int</em>) – Direction in which to get the order.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><strong>ValueError</strong> – For invalid direction</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="splipy.Surface.pardim">
<code class="descname">pardim</code><a class="headerlink" href="#splipy.Surface.pardim" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of parametric dimensions: 1 for curves, 2 for surfaces, 3
for volumes, etc.</p>
</dd></dl>

<dl class="method">
<dt id="splipy.Surface.periodic">
<code class="descname">periodic</code><span class="sig-paren">(</span><em>direction=0</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Surface.periodic" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if the spline object is periodic in the given parametric direction</p>
</dd></dl>

<dl class="method">
<dt id="splipy.Surface.project">
<code class="descname">project</code><span class="sig-paren">(</span><em>plane</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Surface.project" title="Permalink to this definition">¶</a></dt>
<dd><p>Projects the geometry onto a plane or axis.</p>
<ul class="simple">
<li><cite>project(‘xy’)</cite> will project the object onto the <em>xy</em> plane, setting
all <em>z</em> components to zero.</li>
<li><cite>project(‘y’)</cite> will project the object onto the <em>y</em> axis, setting all
<em>x</em> and <em>z</em> components to zero.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>plane</strong> (<em>string</em>) – Any combination of ‘x’, ‘y’ and ‘z’</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">self</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Surface.raise_order">
<code class="descname">raise_order</code><span class="sig-paren">(</span><em>*raises</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Surface.raise_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Raise the polynomial order of the object. If only one argument is
given, the order is raised equally over all directions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>u</strong><strong>,</strong><strong>v</strong><strong>,</strong><strong>..</strong> (<em>int</em>) – Number of times to raise the order in a given
direction.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">self</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Surface.rebuild">
<code class="descname">rebuild</code><span class="sig-paren">(</span><em>p</em>, <em>n</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/Surface.html#Surface.rebuild"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.Surface.rebuild" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates an approximation to this surface by resampling it using
uniform knot vectors of order <em>p</em> with <em>n</em> control points.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>p</strong> (<em>(</em><em>int</em><em>)</em>) – Tuple of polynomial discretization order in each direction</li>
<li><strong>n</strong> (<em>(</em><em>int</em><em>)</em>) – Tuple of number of control points in each direction</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A new approximate surface</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#splipy.Surface" title="splipy.Surface">Surface</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Surface.refine">
<code class="descname">refine</code><span class="sig-paren">(</span><em>*ns</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Surface.refine" title="Permalink to this definition">¶</a></dt>
<dd><p>Enrich the spline space by inserting knots into each existing knot
span.</p>
<p>This method supports three different usage patterns:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Refine each direction by a factor n</span>
<span class="n">obj</span><span class="o">.</span><span class="n">refine</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

<span class="c1"># Refine a single direction by a factor n</span>
<span class="n">obj</span><span class="o">.</span><span class="n">refine</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;v&#39;</span><span class="p">)</span>

<span class="c1"># Refine all directions by given factors</span>
<span class="n">obj</span><span class="o">.</span><span class="n">refine</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">nv</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>nu</strong><strong>,</strong><strong>nv</strong><strong>,</strong><strong>..</strong> (<em>int</em>) – Number of new knots to insert into each span</li>
<li><strong>direction</strong> (<em>int</em>) – Direction to refine in</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">self</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Surface.reparam">
<code class="descname">reparam</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Surface.reparam" title="Permalink to this definition">¶</a></dt>
<dd><p>Redefine the parametric domain. This function accepts two calling
conventions:</p>
<p><cite>reparametrize(u, v, …)</cite> reparametrizes each direction to the domains
given by the tuples <em>u</em>, <em>v</em>, etc. It is equivalent to calling
<cite>reparametrize(u[0], u[1])</cite> on each basis. The default domain for
directions not given is (0,1). In particular, if no arguments are
given, the new parametric domain will be the unit (hyper)cube.</p>
<p><cite>reparametrize(u, direction=d)</cite> reparametrizes just the direction given
by <em>d</em> and leaves the others untouched.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>u</strong><strong>, </strong><strong>v</strong><strong>, </strong><strong>..</strong> (<em>tuple</em>) – New parametric domains, default to (0,1)</li>
<li><strong>direction</strong> (<em>int</em>) – The direction to reparametrize</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">self</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Surface.reverse">
<code class="descname">reverse</code><span class="sig-paren">(</span><em>direction=0</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Surface.reverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Swap the direction of a parameter by making it go in the reverse
direction. The parametric domain remains unchanged.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>direction</strong> (<em>int</em>) – The direction to flip.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">self</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Surface.rotate">
<code class="descname">rotate</code><span class="sig-paren">(</span><em>theta</em>, <em>normal=(0</em>, <em>0</em>, <em>1)</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Surface.rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate the object around an axis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>theta</strong> (<em>float</em>) – Angle to rotate about, measured in radians</li>
<li><strong>normal</strong> (<em>array-like</em>) – The normal axis (if 3D) to rotate about</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>RuntimeError</strong> – If the physical dimension is not 2 or 3</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">self</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Surface.scale">
<code class="descname">scale</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Surface.scale" title="Permalink to this definition">¶</a></dt>
<dd><p>Scale, or magnify the object by a given amount.</p>
<p>In case of one input argument, the scaling is uniform.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>args</strong> (<em>array-like</em><em> or </em><em>float</em>) – Scaling factors, possibly different in each direction.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">self</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Surface.section">
<code class="descname">section</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Surface.section" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a section from the object. A section can be any sub-object of
parametric dimension not exceeding that of the object. E.g. for a
volume, sections include vertices, edges, faces, etc.</p>
<p>The arguments are control point indices for each direction. <cite>None</cite>
means that direction should be variable in the returned object.</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Get the face with u=max</span>
<span class="n">vol</span><span class="o">.</span><span class="n">section</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

<span class="c1"># Keyword arguments are supported for u, v and w</span>
<span class="c1"># This is the same as the above</span>
<span class="n">vol</span><span class="o">.</span><span class="n">section</span><span class="p">(</span><span class="n">u</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Get the edge with u=min, v=max</span>
<span class="n">vol</span><span class="o">.</span><span class="n">section</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

<span class="c1"># This is equivalent to vol.clone()</span>
<span class="n">vol</span><span class="o">.</span><span class="n">section</span><span class="p">()</span>
</pre></div>
</div>
<p>If a specific subclass of <cite>SplineObject</cite> is found that handles the
requested number of variable directions (parametric dimension), then
the return value is of that type. If not, it will be a generic <cite>SplineObject</cite>.</p>
<p>If the section has no variable directions (it is a point), then the
return value will be an array, unless the keyword argument
<cite>unwrap_points</cite> is true, in which case it will return a
zero-dimensional <cite>SplineObject</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>u</strong><strong>,</strong><strong>v</strong><strong>,</strong><strong>..</strong> (<em>int</em><em> or </em><em>None</em>) – Control point indices</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Section</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#splipy.SplineObject" title="splipy.SplineObject">SplineObject</a> or np.array</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Surface.set_dimension">
<code class="descname">set_dimension</code><span class="sig-paren">(</span><em>new_dim</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Surface.set_dimension" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the physical dimension of the object. If increased, the new
components are set to zero.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>new_dim</strong> (<em>int</em>) – New dimension.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">self</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Surface.set_order">
<code class="descname">set_order</code><span class="sig-paren">(</span><em>*order</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Surface.set_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the polynomial order of the object. If only one argument is
given, the order is set uniformly over all directions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>u</strong><strong>,</strong><strong>v</strong><strong>,</strong><strong>..</strong> (<em>int</em>) – The new order in a given direction.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><strong>ValueError</strong> – If the order is reduced in any direction.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">self</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="splipy.Surface.shape">
<code class="descname">shape</code><a class="headerlink" href="#splipy.Surface.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>The dimensions of the control point array.</p>
</dd></dl>

<dl class="method">
<dt id="splipy.Surface.split">
<code class="descname">split</code><span class="sig-paren">(</span><em>knots</em>, <em>direction=0</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Surface.split" title="Permalink to this definition">¶</a></dt>
<dd><p>Split an object into two or more separate representations with C0
continuity between them.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>knots</strong> (<em>float</em><em> or </em><em>[</em><em>float</em><em>]</em>) – The splitting points</li>
<li><strong>direction</strong> (<em>int</em>) – Parametric direction</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The new objects</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">[<a class="reference internal" href="#splipy.SplineObject" title="splipy.SplineObject">SplineObject</a>]</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Surface.start">
<code class="descname">start</code><span class="sig-paren">(</span><em>direction=None</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Surface.start" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the start of the parametric domain.</p>
<p>If <cite>direction</cite> is given, returns the start of that direction, as a
float. If it is not given, returns the start of all directions, as a
tuple.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>direction</strong> (<em>int</em>) – Direction in which to get the start.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><strong>ValueError</strong> – For invalid direction</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Surface.swap">
<code class="descname">swap</code><span class="sig-paren">(</span><em>dir1=0</em>, <em>dir2=1</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Surface.swap" title="Permalink to this definition">¶</a></dt>
<dd><p>Swaps two parameter directions.</p>
<p>This function silently passes for curves.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>dir1</strong> (<em>direction</em>) – The first direction (default u)</li>
<li><strong>dir2</strong> (<em>direction</em>) – The second direction (default v)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">self</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Surface.tangent">
<code class="descname">tangent</code><span class="sig-paren">(</span><em>*params</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Surface.tangent" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the tangents of the object at the given parametric values.</p>
<p>If <cite>direction</cite> is given, only the derivatives in that direction are
evaluated. This is equivalent to calling
<a class="reference internal" href="#splipy.SplineObject.derivative" title="splipy.SplineObject.derivative"><code class="xref py py-func docutils literal notranslate"><span class="pre">splipy.SplineObject.derivative()</span></code></a> with
<cite>d=(0,…,0,1,0,…,0)</cite>, the unit vector corresponding to the given
direction.</p>
<p>If <cite>direction</cite> is not given, this function returns a tuple of all
tangential derivatives at the given points.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>u</strong><strong>,</strong><strong>v</strong><strong>,</strong><strong>..</strong> (<em>float</em><em> or </em><em>[</em><em>float</em><em>]</em>) – Parametric coordinates in which to evaluate</li>
<li><strong>direction</strong> (<em>int</em>) – The tangential direction</li>
<li><strong>above</strong> (<em>(</em><em>bool</em><em>)</em>) – Evaluation in the limit from above</li>
<li><strong>tensor</strong> (<em>bool</em>) – Whether to evaluate on a tensor product grid</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Tangents</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">tuple&lt;numpy.array&gt;</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Surface.translate">
<code class="descname">translate</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Surface.translate" title="Permalink to this definition">¶</a></dt>
<dd><p>Translate (i.e. move) the object by a given distance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>x</strong> (<em>array-like</em>) – The vector to translate by.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">self</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="volume">
<h2>Volume<a class="headerlink" href="#volume" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="splipy.Volume">
<em class="property">class </em><code class="descclassname">splipy.</code><code class="descname">Volume</code><a class="reference internal" href="_modules/splipy/Volume.html#Volume"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.Volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">splipy.SplineObject.SplineObject</span></code></p>
<p>Represents a volume: an object with a three-dimensional parameter space.</p>
<dl class="method">
<dt id="splipy.Volume.evaluate">
<code class="descname">evaluate</code><span class="sig-paren">(</span><em>u</em>, <em>v</em>, <em>w</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Volume.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the volume at the given parametric values.</p>
<p>This function returns an <em>n1</em> × <em>n2</em> × <em>n3</em> × <em>dim</em> array, where <em>ni</em> is
the number of evaluation points in each direction, and <em>dim</em> is the
dimension of the volume.</p>
<p>If there is only one evaluation point, a vector of length <em>dim</em> is
returned instead.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>u</strong> (<em>float</em><em> or </em><em>[</em><em>float</em><em>]</em>) – Parametric coordinates in the first direction</li>
<li><strong>v</strong> (<em>float</em><em> or </em><em>[</em><em>float</em><em>]</em>) – Parametric coordinates in the second direction</li>
<li><strong>w</strong> (<em>float</em><em> or </em><em>[</em><em>float</em><em>]</em>) – Parametric coordinates in the third direction</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Geometry coordinates</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy.array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Volume.evalute_derivative">
<code class="descname">evalute_derivative</code><span class="sig-paren">(</span><em>u</em>, <em>v</em>, <em>w</em><span class="optional">[</span>, <em>d=(1</em>, <em>1</em>, <em>1)</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Volume.evalute_derivative" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the derivative of the volume at the given parametric values.</p>
<p>This function returns an <em>n1</em> × <em>n2</em> × <em>n3</em> × <em>dim</em> array, where <em>ni</em> is
the number of evaluation points in direction <em>i</em>, and <em>dim</em> is the
dimension of the volume.</p>
<p>If there is only one evaluation point, a vector of length <em>dim</em> is
returned instead.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>u</strong> (<em>float</em><em> or </em><em>[</em><em>float</em><em>]</em>) – Parametric coordinates in the first direction</li>
<li><strong>v</strong> (<em>float</em><em> or </em><em>[</em><em>float</em><em>]</em>) – Parametric coordinates in the second direction</li>
<li><strong>w</strong> (<em>float</em><em> or </em><em>[</em><em>float</em><em>]</em>) – Parametric coordinates in the third direction</li>
<li><strong>d</strong> (<em>(</em><em>int</em><em>)</em>) – Order of derivative to compute</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Derivatives</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy.array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Volume.__getitem__">
<code class="descname">__getitem__</code><span class="sig-paren">(</span><em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Volume.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the control point at a given index.</p>
<p>Indexing is in column-major order. Examples of supported indexing
modes:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Flat indexing with an int</span>
<span class="n">obj</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>

<span class="c1"># Flat indexing from the end</span>
<span class="n">obj</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

<span class="c1"># Flat indexing with a slice</span>
<span class="n">obj</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>

<span class="c1"># Multi-indexing with ints, negative ints and slices</span>
<span class="n">obj</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,:]</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">numpy.array</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Volume.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>basis1=None</em>, <em>basis2=None</em>, <em>basis3=None</em>, <em>controlpoints=None</em>, <em>rational=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/Volume.html#Volume.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.Volume.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a volume with the given basis and control points.</p>
<p>The default is to create a linear one-element mapping from and to the
unit cube.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>basis1</strong> (<a class="reference internal" href="#splipy.BSplineBasis" title="splipy.BSplineBasis"><em>BSplineBasis</em></a>) – The basis of the first parameter direction</li>
<li><strong>basis2</strong> (<a class="reference internal" href="#splipy.BSplineBasis" title="splipy.BSplineBasis"><em>BSplineBasis</em></a>) – The basis of the second parameter direction</li>
<li><strong>basis3</strong> (<a class="reference internal" href="#splipy.BSplineBasis" title="splipy.BSplineBasis"><em>BSplineBasis</em></a>) – The basis of the third parameter direction</li>
<li><strong>controlpoints</strong> (<em>array-like</em>) – An <em>n1</em> × <em>n2</em> × <em>n3</em> × <em>d</em> matrix of
control points</li>
<li><strong>rational</strong> (<em>bool</em>) – Whether the volume is rational (in which case the
control points are interpreted as pre-multiplied with the weight,
which is the last coordinate)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Volume.__len__">
<code class="descname">__len__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Volume.__len__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of control points (basis functions) for the object.</p>
</dd></dl>

<dl class="method">
<dt id="splipy.Volume.__setitem__">
<code class="descname">__setitem__</code><span class="sig-paren">(</span><em>i</em>, <em>cp</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Volume.__setitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the control points at given indices.</p>
<p>This function supports the same indexing modes as
<code class="xref py py-func docutils literal notranslate"><span class="pre">SplineObject.__getitem__()</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>i</strong> (<em>int</em>) – Index or indices</li>
<li><strong>cp</strong> (<em>numpy.array</em>) – New control point(s)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Volume.bounding_box">
<code class="descname">bounding_box</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Volume.bounding_box" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the bounding box of a spline object, computed from the
control-point values. Could be inaccurate for rational splines.</p>
<p>Returns the minima and maxima for each direction:
[(xmin, xmax), (ymin, ymax), …]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Bounding box</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">[(float)]</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Volume.center">
<code class="descname">center</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Volume.center" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the center of the domain</p>
<p>For curves this will return <span class="math notranslate">\((\tilde{x}, \tilde{y},...)\)</span>, where</p>
<div class="math notranslate">
\[\tilde{x} = \frac{1}{L} \int_{t_0}^{t_1} x(t) \; dt\]</div>
<p>and <span class="math notranslate">\(L=t_1-t_0\)</span> is the length of the parametric domain <span class="math notranslate">\([t_0,t_1]\)</span>.</p>
<p>For surfaces this will return <span class="math notranslate">\((\tilde{x}, \tilde{y},...)\)</span>, where</p>
<div class="math notranslate">
\[\tilde{x} = \frac{1}{A} \int_{v_0}^{v_1} \int_{u_0}^{u_1} x(u,v) \; du \; dv\]</div>
<p>and <span class="math notranslate">\(A=(u_1-u_0)(v_1-v_0)\)</span> is the area of the parametric domain <span class="math notranslate">\([u_0,u_1]\times[v_0,v_1]\)</span>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">For rational splines, this will integrate in projective
coordinates, then project the centerpoint. This is as opposed to
integrating the rational functions <span class="math notranslate">\(\frac{N_i(t)w_i}{\sum_j
N_j(t)w_j}\)</span>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="splipy.Volume.clone">
<code class="descname">clone</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Volume.clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Clone the object.</p>
</dd></dl>

<dl class="method">
<dt id="splipy.Volume.corners">
<code class="descname">corners</code><span class="sig-paren">(</span><em>order='C'</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Volume.corners" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the corner control points.</p>
<p>The <cite>order</cite> parameter determines which order to use, either <code class="docutils literal notranslate"><span class="pre">'F'</span></code> or
<code class="docutils literal notranslate"><span class="pre">'C'</span></code>, for row-major or column-major ordering. E.g. for a volume, in
parametric coordinates,</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">'C'</span></code> gives (0,0,0), (1,0,0), (0,1,0), (1,1,0), (0,0,1), etc.</li>
<li><code class="docutils literal notranslate"><span class="pre">'F'</span></code> gives (0,0,0), (0,0,1), (0,1,0), (0,1,1), (1,0,0), etc.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>order</strong> (<em>str</em>) – The ordering to use</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Corners</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">np.array</td>
</tr>
</tbody>
</table>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">For rational splines, this will return the corners in
projective coordinates, including weights.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="splipy.Volume.derivative">
<code class="descname">derivative</code><span class="sig-paren">(</span><em>*params</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Volume.derivative" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the derivative of the object at the given parametric values.</p>
<p>If <em>tensor</em> is true, evaluation will take place on a tensor product
grid, i.e. it will return an <em>n1</em> × <em>n2</em> × … × <em>dim</em> array, where
<em>ni</em> is the number of evaluation points in direction <em>i</em>, and <em>dim</em> is
the physical dimension of the object.</p>
<p>If <em>tensor</em> is false, there must be an equal number <em>n</em> of evaluation
points in all directions, and the return value will be an <em>n</em> × <em>dim</em>
array.</p>
<p>If there is only one evaluation point, a vector of length <em>dim</em> is
returned instead.</p>
<p>Examples:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Tangent of curve at single point</span>
<span class="n">curve</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>

<span class="c1"># Double derivative of curve at single point:</span>
<span class="n">curve</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># Third derivative of curve at several points:</span>
<span class="n">curve</span><span class="o">.</span><span class="n">derivative</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> <span class="n">d</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

<span class="c1"># Tangents of surface:</span>
<span class="n">surface</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
<span class="n">surface</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>

<span class="c1"># Cross-derivative of surface:</span>
<span class="n">surface</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>u</strong><strong>,</strong><strong>v</strong><strong>,</strong><strong>..</strong> (<em>float</em><em> or </em><em>[</em><em>float</em><em>]</em>) – Parametric coordinates in which to evaluate</li>
<li><strong>d</strong> (<em>(</em><em>int</em><em>)</em>) – Order of derivative to compute</li>
<li><strong>above</strong> (<em>(</em><em>bool</em><em>)</em>) – Evaluation in the limit from above</li>
<li><strong>tensor</strong> (<em>bool</em>) – Whether to evaluate on a tensor product grid</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Derivatives</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy.array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Volume.edges">
<code class="descname">edges</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/Volume.html#Volume.edges"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.Volume.edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the twelve edges of this volume in order:</p>
<ul class="simple">
<li>umin, vmin</li>
<li>umax, vmin</li>
<li>umin, vmax</li>
<li>umax, vmax</li>
<li>umin, wmin</li>
<li>umax, wmin</li>
<li>umin, wmax</li>
<li>umax, wmax</li>
<li>vmin, wmin</li>
<li>vmax, wmin</li>
<li>vmin, wmax</li>
<li>vmax, wmax</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Edges</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">(<a class="reference internal" href="#splipy.Curve" title="splipy.Curve">Curve</a>)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Volume.end">
<code class="descname">end</code><span class="sig-paren">(</span><em>direction=None</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Volume.end" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the end of the parametric domain.</p>
<p>If <cite>direction</cite> is given, returns the end of that direction, as a float.
If it is not given, returns the end of all directions, as a tuple.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>direction</strong> (<em>int</em>) – Direction in which to get the end.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><strong>ValueError</strong> – For invalid direction</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Volume.faces">
<code class="descname">faces</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/Volume.html#Volume.faces"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.Volume.faces" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the six faces of this volume in order: umin, umax, vmin, vmax, wmin, wmax.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Boundary faces</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">(<a class="reference internal" href="#splipy.Surface" title="splipy.Surface">Surface</a>)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Volume.force_rational">
<code class="descname">force_rational</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Volume.force_rational" title="Permalink to this definition">¶</a></dt>
<dd><p>Force a rational representation of the object.</p>
<p>The weights of a non-rational object will be set to 1.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">self</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Volume.get_derivative_spline">
<code class="descname">get_derivative_spline</code><span class="sig-paren">(</span><em>direction=None</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Volume.get_derivative_spline" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the controlpoints associated with the derivative spline object</p>
<p>If <cite>direction</cite> is given, only the derivatives in that direction are
returned.</p>
<p>If <cite>direction</cite> is not given, this function returns a tuple of all
partial derivatives</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create a 4x4 element cubic spline surface</span>
<span class="n">surf</span> <span class="o">=</span> <span class="n">Surface</span><span class="p">()</span>
<span class="n">surf</span><span class="o">.</span><span class="n">raise_order</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">surf</span><span class="o">.</span><span class="n">refine</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="n">surf</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">,:]</span> <span class="o">+=</span> <span class="mf">0.1</span> <span class="c1"># make the surface non-trivial by moving controlpoints</span>

<span class="c1"># Create the derivative surface</span>
<span class="n">du</span> <span class="o">=</span> <span class="n">surf</span><span class="o">.</span><span class="n">get_derivative_spline</span><span class="p">(</span><span class="n">direction</span><span class="o">=</span><span class="s1">&#39;u&#39;</span><span class="p">)</span>

<span class="c1"># evaluation is identical</span>
<span class="nb">print</span><span class="p">(</span><span class="n">du</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">surf</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)))</span>

<span class="nb">print</span><span class="p">(</span><span class="n">surf</span><span class="o">.</span><span class="n">order</span><span class="p">())</span> <span class="c1"># prints (3,3)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">du</span><span class="o">.</span><span class="n">order</span><span class="p">())</span>   <span class="c1"># prints (2,3)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>direction</strong> (<em>int</em>) – The tangential direction</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Derivative spline</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#splipy.SplineObject" title="splipy.SplineObject">SplineObject</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Volume.get_derivative_volume">
<code class="descname">get_derivative_volume</code><span class="sig-paren">(</span><em>direction=None</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Volume.get_derivative_volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the controlpoints associated with the derivative spline object</p>
<p>If <cite>direction</cite> is given, only the derivatives in that direction are
returned.</p>
<p>If <cite>direction</cite> is not given, this function returns a tuple of all
partial derivatives</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create a 4x4 element cubic spline surface</span>
<span class="n">surf</span> <span class="o">=</span> <span class="n">Surface</span><span class="p">()</span>
<span class="n">surf</span><span class="o">.</span><span class="n">raise_order</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">surf</span><span class="o">.</span><span class="n">refine</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="n">surf</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">,:]</span> <span class="o">+=</span> <span class="mf">0.1</span> <span class="c1"># make the surface non-trivial by moving controlpoints</span>

<span class="c1"># Create the derivative surface</span>
<span class="n">du</span> <span class="o">=</span> <span class="n">surf</span><span class="o">.</span><span class="n">get_derivative_spline</span><span class="p">(</span><span class="n">direction</span><span class="o">=</span><span class="s1">&#39;u&#39;</span><span class="p">)</span>

<span class="c1"># evaluation is identical</span>
<span class="nb">print</span><span class="p">(</span><span class="n">du</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">surf</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)))</span>

<span class="nb">print</span><span class="p">(</span><span class="n">surf</span><span class="o">.</span><span class="n">order</span><span class="p">())</span> <span class="c1"># prints (3,3)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">du</span><span class="o">.</span><span class="n">order</span><span class="p">())</span>   <span class="c1"># prints (2,3)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>direction</strong> (<em>int</em>) – The tangential direction</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Derivative spline</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#splipy.SplineObject" title="splipy.SplineObject">SplineObject</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Volume.insert_knot">
<code class="descname">insert_knot</code><span class="sig-paren">(</span><em>knot</em>, <em>direction=0</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Volume.insert_knot" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert a new knot into the spline.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>direction</strong> (<em>int</em>) – The direction to insert in</li>
<li><strong>knot</strong> (<em>float</em><em> or </em><em>[</em><em>float</em><em>]</em>) – The new knot(s) to insert</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>ValueError</strong> – For invalid direction</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">self</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Volume.knots">
<code class="descname">knots</code><span class="sig-paren">(</span><em>direction=None</em>, <em>with_multiplicities=False</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Volume.knots" title="Permalink to this definition">¶</a></dt>
<dd><p>Return knots vector</p>
<p>If <cite>direction</cite> is given, returns the knots in that direction, as a
list. If it is not given, returns the knots of all directions, as a
tuple.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>direction</strong> (<em>int</em>) – Direction in which to get the knots.</li>
<li><strong>with_multiplicities</strong> (<em>bool</em>) – If true, return knots with
multiplicities (i.e. repeated).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><strong>ValueError</strong> – For invalid direction</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Volume.lower_order">
<code class="descname">lower_order</code><span class="sig-paren">(</span><em>*lowers</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Volume.lower_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Lower the polynomial order of the object. If only one argument is
given, the order is lowered equally over all directions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>u</strong><strong>,</strong><strong>v</strong><strong>,</strong><strong>..</strong> (<em>int</em>) – Number of times to lower the order in a given
direction.</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Return SplineObject:</th></tr>
<tr class="field-even field"><td>&#160;</td><td class="field-body">Approximation of the current object on a lower
order basis</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Volume.lower_periodic">
<code class="descname">lower_periodic</code><span class="sig-paren">(</span><em>periodic</em>, <em>direction=0</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Volume.lower_periodic" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the periodicity of the spline object in the given direction,
keeping the geometry unchanged.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>periodic</strong> (<em>int</em>) – new periodicity, i.e. the basis is C^k over the start/end</li>
<li><strong>direction</strong> (<em>int</em>) – the parametric direction of the basis to modify</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">self</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Volume.make_periodic">
<code class="descname">make_periodic</code><span class="sig-paren">(</span><em>continuity=None</em>, <em>direction=0</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Volume.make_periodic" title="Permalink to this definition">¶</a></dt>
<dd><p>Make the spline object periodic in a given parametric direction.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>continuity</strong> (<em>int</em>) – The continuity along the boundary (default max).</li>
<li><strong>direction</strong> (<em>int</em>) – The direction to ensure continuity in.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="splipy.Volume.make_splines_compatible">
<em class="property">classmethod </em><code class="descname">make_splines_compatible</code><span class="sig-paren">(</span><em>spline1</em>, <em>spline2</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Volume.make_splines_compatible" title="Permalink to this definition">¶</a></dt>
<dd><p>Ensure that two splines are compatible.</p>
<p>This will manipulate one or both to ensure that they are both rational
or nonrational, and that they lie in the same physical space.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>spline1</strong> (<a class="reference internal" href="#splipy.SplineObject" title="splipy.SplineObject"><em>SplineObject</em></a>) – The first spline</li>
<li><strong>spline2</strong> (<a class="reference internal" href="#splipy.SplineObject" title="splipy.SplineObject"><em>SplineObject</em></a>) – The second spline</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="splipy.Volume.make_splines_identical">
<em class="property">classmethod </em><code class="descname">make_splines_identical</code><span class="sig-paren">(</span><em>spline1</em>, <em>spline2</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Volume.make_splines_identical" title="Permalink to this definition">¶</a></dt>
<dd><p>Ensure that two splines have identical discretization.</p>
<p>This will first make them compatible (see
<code class="xref py py-func docutils literal notranslate"><span class="pre">splipy.SplineObject.make_curves_compatible()</span></code>), reparametrize them, and
possibly raise the order and insert knots as required.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>spline1</strong> (<a class="reference internal" href="#splipy.SplineObject" title="splipy.SplineObject"><em>SplineObject</em></a>) – The first spline</li>
<li><strong>spline2</strong> (<a class="reference internal" href="#splipy.SplineObject" title="splipy.SplineObject"><em>SplineObject</em></a>) – The second spline</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Volume.mirror">
<code class="descname">mirror</code><span class="sig-paren">(</span><em>normal</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Volume.mirror" title="Permalink to this definition">¶</a></dt>
<dd><p>Mirror the object around a plane through the origin.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>normal</strong> (<em>array-like</em>) – The plane normal to mirror about.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><strong>RuntimeError</strong> – If the physical dimension is not 2 or 3</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">self</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Volume.order">
<code class="descname">order</code><span class="sig-paren">(</span><em>direction=None</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Volume.order" title="Permalink to this definition">¶</a></dt>
<dd><p>Return polynomial order (degree + 1).</p>
<p>If <cite>direction</cite> is given, returns the order of that direction, as an
int. If it is not given, returns the order of all directions, as a
tuple.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>direction</strong> (<em>int</em>) – Direction in which to get the order.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><strong>ValueError</strong> – For invalid direction</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="splipy.Volume.pardim">
<code class="descname">pardim</code><a class="headerlink" href="#splipy.Volume.pardim" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of parametric dimensions: 1 for curves, 2 for surfaces, 3
for volumes, etc.</p>
</dd></dl>

<dl class="method">
<dt id="splipy.Volume.periodic">
<code class="descname">periodic</code><span class="sig-paren">(</span><em>direction=0</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Volume.periodic" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if the spline object is periodic in the given parametric direction</p>
</dd></dl>

<dl class="method">
<dt id="splipy.Volume.project">
<code class="descname">project</code><span class="sig-paren">(</span><em>plane</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Volume.project" title="Permalink to this definition">¶</a></dt>
<dd><p>Projects the geometry onto a plane or axis.</p>
<ul class="simple">
<li><cite>project(‘xy’)</cite> will project the object onto the <em>xy</em> plane, setting
all <em>z</em> components to zero.</li>
<li><cite>project(‘y’)</cite> will project the object onto the <em>y</em> axis, setting all
<em>x</em> and <em>z</em> components to zero.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>plane</strong> (<em>string</em>) – Any combination of ‘x’, ‘y’ and ‘z’</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">self</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Volume.raise_order">
<code class="descname">raise_order</code><span class="sig-paren">(</span><em>*raises</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Volume.raise_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Raise the polynomial order of the object. If only one argument is
given, the order is raised equally over all directions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>u</strong><strong>,</strong><strong>v</strong><strong>,</strong><strong>..</strong> (<em>int</em>) – Number of times to raise the order in a given
direction.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">self</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Volume.rebuild">
<code class="descname">rebuild</code><span class="sig-paren">(</span><em>p</em>, <em>n</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/Volume.html#Volume.rebuild"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.Volume.rebuild" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates an approximation to this volume by resampling it using
uniform knot vectors of order <em>p</em> with <em>n</em> control points.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>p</strong> (<em>(</em><em>int</em><em>)</em>) – Tuple of polynomial discretization order in each direction</li>
<li><strong>n</strong> (<em>(</em><em>int</em><em>)</em>) – Tuple of number of control points in each direction</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A new approximate volume</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#splipy.Volume" title="splipy.Volume">Volume</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Volume.refine">
<code class="descname">refine</code><span class="sig-paren">(</span><em>*ns</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Volume.refine" title="Permalink to this definition">¶</a></dt>
<dd><p>Enrich the spline space by inserting knots into each existing knot
span.</p>
<p>This method supports three different usage patterns:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Refine each direction by a factor n</span>
<span class="n">obj</span><span class="o">.</span><span class="n">refine</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

<span class="c1"># Refine a single direction by a factor n</span>
<span class="n">obj</span><span class="o">.</span><span class="n">refine</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;v&#39;</span><span class="p">)</span>

<span class="c1"># Refine all directions by given factors</span>
<span class="n">obj</span><span class="o">.</span><span class="n">refine</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">nv</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>nu</strong><strong>,</strong><strong>nv</strong><strong>,</strong><strong>..</strong> (<em>int</em>) – Number of new knots to insert into each span</li>
<li><strong>direction</strong> (<em>int</em>) – Direction to refine in</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">self</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Volume.reparam">
<code class="descname">reparam</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Volume.reparam" title="Permalink to this definition">¶</a></dt>
<dd><p>Redefine the parametric domain. This function accepts two calling
conventions:</p>
<p><cite>reparametrize(u, v, …)</cite> reparametrizes each direction to the domains
given by the tuples <em>u</em>, <em>v</em>, etc. It is equivalent to calling
<cite>reparametrize(u[0], u[1])</cite> on each basis. The default domain for
directions not given is (0,1). In particular, if no arguments are
given, the new parametric domain will be the unit (hyper)cube.</p>
<p><cite>reparametrize(u, direction=d)</cite> reparametrizes just the direction given
by <em>d</em> and leaves the others untouched.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>u</strong><strong>, </strong><strong>v</strong><strong>, </strong><strong>..</strong> (<em>tuple</em>) – New parametric domains, default to (0,1)</li>
<li><strong>direction</strong> (<em>int</em>) – The direction to reparametrize</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">self</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Volume.reverse">
<code class="descname">reverse</code><span class="sig-paren">(</span><em>direction=0</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Volume.reverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Swap the direction of a parameter by making it go in the reverse
direction. The parametric domain remains unchanged.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>direction</strong> (<em>int</em>) – The direction to flip.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">self</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Volume.rotate">
<code class="descname">rotate</code><span class="sig-paren">(</span><em>theta</em>, <em>normal=(0</em>, <em>0</em>, <em>1)</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Volume.rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate the object around an axis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>theta</strong> (<em>float</em>) – Angle to rotate about, measured in radians</li>
<li><strong>normal</strong> (<em>array-like</em>) – The normal axis (if 3D) to rotate about</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>RuntimeError</strong> – If the physical dimension is not 2 or 3</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">self</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Volume.scale">
<code class="descname">scale</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Volume.scale" title="Permalink to this definition">¶</a></dt>
<dd><p>Scale, or magnify the object by a given amount.</p>
<p>In case of one input argument, the scaling is uniform.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>args</strong> (<em>array-like</em><em> or </em><em>float</em>) – Scaling factors, possibly different in each direction.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">self</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Volume.section">
<code class="descname">section</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Volume.section" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a section from the object. A section can be any sub-object of
parametric dimension not exceeding that of the object. E.g. for a
volume, sections include vertices, edges, faces, etc.</p>
<p>The arguments are control point indices for each direction. <cite>None</cite>
means that direction should be variable in the returned object.</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Get the face with u=max</span>
<span class="n">vol</span><span class="o">.</span><span class="n">section</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

<span class="c1"># Keyword arguments are supported for u, v and w</span>
<span class="c1"># This is the same as the above</span>
<span class="n">vol</span><span class="o">.</span><span class="n">section</span><span class="p">(</span><span class="n">u</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Get the edge with u=min, v=max</span>
<span class="n">vol</span><span class="o">.</span><span class="n">section</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

<span class="c1"># This is equivalent to vol.clone()</span>
<span class="n">vol</span><span class="o">.</span><span class="n">section</span><span class="p">()</span>
</pre></div>
</div>
<p>If a specific subclass of <cite>SplineObject</cite> is found that handles the
requested number of variable directions (parametric dimension), then
the return value is of that type. If not, it will be a generic <cite>SplineObject</cite>.</p>
<p>If the section has no variable directions (it is a point), then the
return value will be an array, unless the keyword argument
<cite>unwrap_points</cite> is true, in which case it will return a
zero-dimensional <cite>SplineObject</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>u</strong><strong>,</strong><strong>v</strong><strong>,</strong><strong>..</strong> (<em>int</em><em> or </em><em>None</em>) – Control point indices</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Section</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#splipy.SplineObject" title="splipy.SplineObject">SplineObject</a> or np.array</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Volume.set_dimension">
<code class="descname">set_dimension</code><span class="sig-paren">(</span><em>new_dim</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Volume.set_dimension" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the physical dimension of the object. If increased, the new
components are set to zero.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>new_dim</strong> (<em>int</em>) – New dimension.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">self</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Volume.set_order">
<code class="descname">set_order</code><span class="sig-paren">(</span><em>*order</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Volume.set_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the polynomial order of the object. If only one argument is
given, the order is set uniformly over all directions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>u</strong><strong>,</strong><strong>v</strong><strong>,</strong><strong>..</strong> (<em>int</em>) – The new order in a given direction.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><strong>ValueError</strong> – If the order is reduced in any direction.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">self</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="splipy.Volume.shape">
<code class="descname">shape</code><a class="headerlink" href="#splipy.Volume.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>The dimensions of the control point array.</p>
</dd></dl>

<dl class="method">
<dt id="splipy.Volume.split">
<code class="descname">split</code><span class="sig-paren">(</span><em>knots</em>, <em>direction=0</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Volume.split" title="Permalink to this definition">¶</a></dt>
<dd><p>Split an object into two or more separate representations with C0
continuity between them.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>knots</strong> (<em>float</em><em> or </em><em>[</em><em>float</em><em>]</em>) – The splitting points</li>
<li><strong>direction</strong> (<em>int</em>) – Parametric direction</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The new objects</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">[<a class="reference internal" href="#splipy.SplineObject" title="splipy.SplineObject">SplineObject</a>]</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Volume.start">
<code class="descname">start</code><span class="sig-paren">(</span><em>direction=None</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Volume.start" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the start of the parametric domain.</p>
<p>If <cite>direction</cite> is given, returns the start of that direction, as a
float. If it is not given, returns the start of all directions, as a
tuple.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>direction</strong> (<em>int</em>) – Direction in which to get the start.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><strong>ValueError</strong> – For invalid direction</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Volume.swap">
<code class="descname">swap</code><span class="sig-paren">(</span><em>dir1=0</em>, <em>dir2=1</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Volume.swap" title="Permalink to this definition">¶</a></dt>
<dd><p>Swaps two parameter directions.</p>
<p>This function silently passes for curves.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>dir1</strong> (<em>direction</em>) – The first direction (default u)</li>
<li><strong>dir2</strong> (<em>direction</em>) – The second direction (default v)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">self</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Volume.tangent">
<code class="descname">tangent</code><span class="sig-paren">(</span><em>*params</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Volume.tangent" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the tangents of the object at the given parametric values.</p>
<p>If <cite>direction</cite> is given, only the derivatives in that direction are
evaluated. This is equivalent to calling
<a class="reference internal" href="#splipy.SplineObject.derivative" title="splipy.SplineObject.derivative"><code class="xref py py-func docutils literal notranslate"><span class="pre">splipy.SplineObject.derivative()</span></code></a> with
<cite>d=(0,…,0,1,0,…,0)</cite>, the unit vector corresponding to the given
direction.</p>
<p>If <cite>direction</cite> is not given, this function returns a tuple of all
tangential derivatives at the given points.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>u</strong><strong>,</strong><strong>v</strong><strong>,</strong><strong>..</strong> (<em>float</em><em> or </em><em>[</em><em>float</em><em>]</em>) – Parametric coordinates in which to evaluate</li>
<li><strong>direction</strong> (<em>int</em>) – The tangential direction</li>
<li><strong>above</strong> (<em>(</em><em>bool</em><em>)</em>) – Evaluation in the limit from above</li>
<li><strong>tensor</strong> (<em>bool</em>) – Whether to evaluate on a tensor product grid</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Tangents</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">tuple&lt;numpy.array&gt;</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Volume.translate">
<code class="descname">translate</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#splipy.Volume.translate" title="Permalink to this definition">¶</a></dt>
<dd><p>Translate (i.e. move) the object by a given distance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>x</strong> (<em>array-like</em>) – The vector to translate by.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">self</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="splipy.Volume.volume">
<code class="descname">volume</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/splipy/Volume.html#Volume.volume"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#splipy.Volume.volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the volume of the object in geometric space</p>
</dd></dl>

</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Basic classes</a><ul>
<li><a class="reference internal" href="#bsplinebasis">BSplineBasis</a></li>
<li><a class="reference internal" href="#splineobject">SplineObject</a></li>
<li><a class="reference internal" href="#curve">Curve</a></li>
<li><a class="reference internal" href="#surface">Surface</a></li>
<li><a class="reference internal" href="#volume">Volume</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/basic_classes.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Splipy 1.2.0 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, Arne Morten Kvarving, Kjetil Andre Johannessen, Eivind Fonn.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.1.
    </div>
  </body>
</html>